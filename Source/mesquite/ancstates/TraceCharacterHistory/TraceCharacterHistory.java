/* Mesquite source code.  Copyright 1997-2007 W. Maddison and D. Maddison.Version 2.0, September 2007.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.ancstates.TraceCharacterHistory;import java.util.*;import java.awt.*;import java.awt.event.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;/* ======================================================================== */public class TraceCharacterHistory extends TreeDisplayAssistantMA {	public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed		EmployeeNeed e2 = registerEmployeeNeed(CharHistorySource.class, getName() + " needs a source of character histories.",		"The source of a traced history is be default a reconstruction from a supplied character distribution.  Afterwards you may choose an alternative source using the Character History Source submenu");		EmployeeNeed e3 = registerEmployeeNeed(DisplayStatesAtNodes.class, getName() + " needs a method to display the results.",		"The method to display results can be selected in the Trace Display Mode submenu");		EmployeeNeed e4 = registerEmployeeNeed(TraceCharacterInit.class, getName() + " uses assistant modules to extend the analysis.",				"These assistant modules are arranged automatically by " + getName());	}	CharHistorySource historyTask;	DisplayStatesAtNodes displayTask;	private CharacterHistory currentHistory=null;	private Tree currentTree=null;	private Taxa currentTaxa=null;	int currentChar=0;	int currentMapping = 0;	int lastCharRetrieved = -1;	private String currentCharacterName;	MesquiteString historyTaskName;	MesquiteString displayTaskName;	public MesquiteBoolean showLegend;	int initialOffsetX=MesquiteInteger.unassigned;	int initialOffsetY= MesquiteInteger.unassigned;	int initialLegendWidth=MesquiteInteger.unassigned;	int initialLegendHeight= MesquiteInteger.unassigned;	Vector traces;	MesquiteCommand htC, dtC;	MesquiteBoolean showStateWeights;	MesquiteBoolean useGray;	boolean suspend = false;	MesquiteMenuItemSpec propWeight = null;	MesquiteMenuItemSpec  revertColorsItem;	boolean enableStore = true;	Point[] whichColorsModified = new Point[64];	Color[] newColors = new Color[64];	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		showLegend = new MesquiteBoolean(true);		suspend = MesquiteThread.isScripting();		historyTask = (CharHistorySource)hireNamedEmployee(CharHistorySource.class, "#RecAncestralStates");		if (historyTask == null)			historyTask = (CharHistorySource)hireEmployee(CharHistorySource.class, "Source of character histories to trace");		if (historyTask == null) {			return sorry(getName() + " couldn't start because source of character histories not obtained.");		}		historyTaskName = new MesquiteString(historyTask.getName());		traces = new Vector();		displayTask = (DisplayStatesAtNodes)hireEmployee(DisplayStatesAtNodes.class, null);		if (displayTask == null) {			return sorry(getName() + " couldn't start because display module not obtained.");		}		dtC = makeCommand("setDisplayMode",  this);		displayTask.setHiringCommand(dtC);		makeMenu("Trace");		resetContainingMenuBar();		displayTaskName = new MesquiteString(displayTask.getName());		htC = makeCommand("setHistorySource",  this);		if (numModulesAvailable(CharHistorySource.class)>1) {			historyTask.setHiringCommand(htC);			MesquiteSubmenuSpec mss = addSubmenu(null, "Character History Source", htC, CharHistorySource.class);			mss.setSelected(historyTaskName);		}		MesquiteMenuItemSpec mm = addMenuItem( "Next " + historyTask.getHistoryTypeName(), makeCommand("nextCharacter",  this));		mm.setShortcut(KeyEvent.VK_RIGHT); //right		mm = addMenuItem( "Previous " + historyTask.getHistoryTypeName(), makeCommand("previousCharacter",  this));		mm.setShortcut(KeyEvent.VK_LEFT); //right		addMenuItem( "Choose " + historyTask.getHistoryTypeName(), makeCommand("chooseCharacter",  this));		if (enableStore)			addMenuItem( "Store History...", makeCommand("storeHistory",  this));		addCheckMenuItem(null, "Show Legend", makeCommand("toggleShowLegend",  this), showLegend);		MesquiteSubmenuSpec msDT = addSubmenu(null, "Trace Display Mode", dtC, DisplayStatesAtNodes.class); 		msDT.setSelected(displayTaskName);		useGray = new MesquiteBoolean(false);		addCheckMenuItem(null, "Use Grayscale", makeCommand("toggleGray", this), useGray);		revertColorsItem = addMenuItem("Revert to Default Colors", makeCommand("revertColors", this));		revertColorsItem.setEnabled(false);		showStateWeights = new MesquiteBoolean(true);		propWeight = addCheckMenuItem(null, "Display Proportional to Weight", makeCommand("toggleWeights", this), showStateWeights);		propWeight.setEnabled(historyTask.allowsStateWeightChoice());		MesquiteTrunk.resetMenuItemEnabling();		addMenuItem( "Close Trace", makeCommand("closeTrace",  this));		addMenuItem( "-", null);		hireAllEmployees(TraceCharacterInit.class);		Enumeration enumeration=getEmployeeVector().elements();		while (enumeration.hasMoreElements()){			Object obj = enumeration.nextElement();			if (obj instanceof TraceCharacterInit) {				TraceCharacterInit init = (TraceCharacterInit)obj;				init.setCharacterHistoryContainers(traces);			}		}		return true;	}	/*.................................................................................................................*/	/** Generated by an employee who quit.  The MesquiteModule should act accordingly. */	public void employeeQuit(MesquiteModule employee) {		if (employee == displayTask || employee == historyTask)  			iQuit();	}	/*.................................................................................................................*/	public   TreeDisplayExtra createTreeDisplayExtra(TreeDisplay treeDisplay) {		TraceCharacterOperator newTrace = new TraceCharacterOperator(this, treeDisplay);		traces.addElement(newTrace);		return newTrace;	}	/*.................................................................................................................*/	public boolean showLegend(){		return showLegend.getValue();	}	public int getInitialOffsetX(){		return initialOffsetX;	}	public int getInitialOffsetY(){		return initialOffsetY;	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		temp.addLine("suspend ");		temp.addLine("setDisplayMode ",displayTask);		temp.addLine("setHistorySource ",historyTask);		temp.addLine("setCharacter " + CharacterStates.toExternal(currentChar));		temp.addLine("setMapping " + CharacterStates.toExternal(currentMapping));		temp.addLine("toggleShowLegend " + showLegend.toOffOnString());		temp.addLine("toggleGray " + useGray.toOffOnString());		temp.addLine("toggleWeights " + showStateWeights.toOffOnString());		TraceCharacterOperator tco = (TraceCharacterOperator)traces.elementAt(0);		if (tco!=null && tco.traceLegend!=null) {			temp.addLine("setInitialOffsetX " + tco.traceLegend.getOffsetX()); //Should go operator by operator!!!			temp.addLine("setInitialOffsetY " + tco.traceLegend.getOffsetY());			temp.addLine("setLegendWidth " + tco.traceLegend.getLegendWidth()); //Should go operator by operator!!!			temp.addLine("setLegendHeight " + tco.traceLegend.getLegendHeight());		}		temp.addLine("resume ");		if (tco!=null && tco.traceLegend!=null) {			temp.addLine(tco.traceLegend.getModColorsCommand());		}		return temp;	}	boolean suspendCommandReceived = false;	MesquiteInteger pos = new MesquiteInteger();	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Sets module used to display character history", "[name of module]", commandName, "setDisplayMode")) {			DisplayStatesAtNodes temp=  (DisplayStatesAtNodes)replaceEmployee(DisplayStatesAtNodes.class, arguments, "Display mode", displayTask);			if (temp!=null) {				displayTask= temp;				displayTask.setHiringCommand(dtC);				displayTaskName.setValue(displayTask.getName());				resetFromScratchAllTraceOperators();				if (!MesquiteThread.isScripting())					parametersChanged();			}			return displayTask;		}		else if (checker.compare(this.getClass(), "Sets modified colors", "", commandName, "modifyColors")) {			pos.setValue(0); 			int i = 0; 			whichColorsModified = new Point[64];			newColors = new Color[64];			int count = 0;			while (MesquiteInteger.isCombinable(i= MesquiteInteger.fromString(arguments, pos))){				int j =  MesquiteInteger.fromString(arguments, pos);				int red =  MesquiteInteger.fromString(arguments, pos);				int green =  MesquiteInteger.fromString(arguments, pos);				int blue =  MesquiteInteger.fromString(arguments, pos);				if (MesquiteInteger.isCombinable(j) && MesquiteInteger.isCombinable(red) && MesquiteInteger.isCombinable(green) && MesquiteInteger.isCombinable(blue)){					newColors[count] = new Color(red, green, blue);					whichColorsModified[count++] = new Point(i, j);				}			}			if (count>0){				revertColorsItem.setEnabled(true);				MesquiteTrunk.resetMenuItemEnabling();				notifyIncorpModColorsAllTO();				parametersChanged();			}		}		else if (checker.compare(this.getClass(), "Reverts colors to defaults", "", commandName, "revertColors")) {			revertColorsAllTO();			revertColorsItem.setEnabled(false);			MesquiteTrunk.resetMenuItemEnabling();			parametersChanged();		}		else if (checker.compare(this.getClass(), "Sets whether or not the legend is shown", "[on = show; off]", commandName, "toggleShowLegend")) {			showLegend.toggleValue(parser.getFirstToken(arguments));			toggleLegendAllTraceOperators();			if (MesquiteThread.isScripting() && !suspendCommandReceived){ //must be old script				suspend = false;				recalculateAllTraceOperators(true);  				parametersChanged();			}		}		else if (checker.compare(this.getClass(), "Sets whether or not the weights on states are shown (e.g. relative frequencies or likelihoods)", "[on; off]", commandName, "toggleWeights")) {			showStateWeights.toggleValue(parser.getFirstToken(arguments));			resetAllTraceOperators();			parametersChanged();		}		else if (checker.compare(this.getClass(), "Sets whether or not to use grayscale if continuous", "[on; off]", commandName, "toggleGray")) {			useGray.toggleValue(parser.getFirstToken(arguments));			resetAllTraceOperators();			parametersChanged();		}		else if (checker.compare(this.getClass(), "Suspends calculations", null, commandName, "suspend")) {			suspend = true;			suspendCommandReceived = true;		}		else if (checker.compare(this.getClass(), "Resume calculations", null, commandName, "resume")) {			suspend = false;			suspendCommandReceived = false;			recalculateAllTraceOperators(true);			parametersChanged();		}		/*  The following is disabled for the moment, as storing and retrieving of character histories is not yet supported */		else if (enableStore && checker.compare(this.getClass(), "Stores the current character history", null, commandName, "storeHistory")) {			//todo: if more than one traced, query user which one to store본본본본본본본본본본			TraceCharacterOperator tco = (TraceCharacterOperator)traces.elementAt(0);			if (tco!=null && tco.traceLegend!=null && tco.history!=null && tco.myTree!=null) {				CharacterHistory history = tco.history;				CharacterHistory cloned = history.clone(null);				Tree tree = tco.myTree.cloneTree();				String s = MesquiteString.queryString(containerOfModule(), "Store History" , "Name of History: ", history.getName() );				if (s==null)					return null;				cloned.setName(s);				StoredCharacterHistory sHistory = new StoredCharacterHistory(cloned, tree);				if (sHistory!=null) {					sHistory.setName(s);					sHistory.addToFile( getProject().getHomeFile(), getProject(), findElementManager(StoredCharacterHistory.class));  //TODO: should allow user to choose if more than one file					getProject().addFileElement(sHistory);				} //TODO: should set current tree to show this one if stored trees used			}		}		/*  	*/		else if (checker.compare(this.getClass(), "Sets initial horizontal offset of legend from home position", "[offset in pixels]", commandName, "setInitialOffsetX")) {			int offset= MesquiteInteger.fromFirstToken(arguments, pos);			if (MesquiteInteger.isCombinable(offset)) {				initialOffsetX = offset;				Enumeration e = traces.elements();				while (e.hasMoreElements()) {					Object obj = e.nextElement();					if (obj instanceof TraceCharacterOperator) {						TraceCharacterOperator tCO = (TraceCharacterOperator)obj;						if (tCO.traceLegend!=null)							tCO.traceLegend.setOffsetX(offset);					}				}			}		}		else if (checker.compare(this.getClass(), "Sets initial vertical offset of legend from home position", "[offset in pixels]", commandName, "setInitialOffsetY")) {			int offset= MesquiteInteger.fromFirstToken(arguments, pos);			if (MesquiteInteger.isCombinable(offset)) {				initialOffsetY = offset;				Enumeration e = traces.elements();				while (e.hasMoreElements()) {					Object obj = e.nextElement();					if (obj instanceof TraceCharacterOperator) {						TraceCharacterOperator tCO = (TraceCharacterOperator)obj;						if (tCO.traceLegend!=null)							tCO.traceLegend.setOffsetY(offset);					}				}			}		}		else if (checker.compare(this.getClass(), "Sets initial width of legend", "[width in pixels]", commandName, "setLegendWidth")) {			int x= MesquiteInteger.fromFirstToken(arguments, pos);			if (MesquiteInteger.isCombinable(x)) {				initialLegendWidth = x;				if (initialLegendWidth<50)					initialLegendWidth=50;				Enumeration e = traces.elements();				while (e.hasMoreElements()) {					Object obj = e.nextElement();					if (obj instanceof TraceCharacterOperator) {						TraceCharacterOperator tCO = (TraceCharacterOperator)obj;						if (tCO.traceLegend!=null)							tCO.traceLegend.setLegendWidth(x);					}				}			}		}		else if (checker.compare(this.getClass(), "Sets initial height of legend", "[height in pixels]", commandName, "setLegendHeight")) {			int x= MesquiteInteger.fromFirstToken(arguments, pos);			if (MesquiteInteger.isCombinable(x)) {				initialLegendHeight = x;				if (initialLegendHeight<50)					initialLegendHeight=50;				Enumeration e = traces.elements();				while (e.hasMoreElements()) {					Object obj = e.nextElement();					if (obj instanceof TraceCharacterOperator) {						TraceCharacterOperator tCO = (TraceCharacterOperator)obj;						if (tCO.traceLegend!=null)							tCO.traceLegend.setLegendHeight(x);					}				}			}		}		else if (checker.compare(this.getClass(), "Sets module supplying character histories", "[name of module]", commandName, "setHistorySource")) {			CharHistorySource temp =  (CharHistorySource)replaceEmployee(CharHistorySource.class, arguments, "Source of character histories", historyTask);			if (temp!=null) {				historyTask=  temp;				historyTask.setHiringCommand(htC);				historyTaskName.setValue(historyTask.getName());				propWeight.setEnabled(historyTask.allowsStateWeightChoice());				MesquiteTrunk.resetMenuItemEnabling();				currentChar=0;				resetAllTraceOperators();				recalculateAllTraceOperators(true);				if (!MesquiteThread.isScripting())					parametersChanged();			}			return historyTask;		}		else if (checker.compare(this.getClass(), "NOT YET USED", null, commandName, "newAssistant")) {			/* preparing for assistants to explore character correlation etc. based on reconstruction or shown character    	 		incrementMenuResetSuppression();    	 		TraceAssistant ntt= (TraceAssistant)hireNamedEmployee(TraceAssistant.class, arguments);			decrementMenuResetSuppression();			if (ntt!=null) {    	 			ntt.setUseMenubar(false);				Enumeration e = traces.elements();				while (e.hasMoreElements()) {					Object obj = e.nextElement();					if (obj instanceof TraceLegendOperator) {						TraceLegendOperator tLO = (TraceLegendOperator)obj;						???????			 		}				}				resetContainingMenuBar();			}			return ntt;			 */		}		else if (checker.compare(this.getClass(), "Goes to next character history", null, commandName, "nextCharacter")) {			if (currentChar>=historyTask.getNumberOfHistories(currentTaxa)-1)				currentChar=0;			else				currentChar++;			recalculateAllTraceOperators(true);		}		else if (checker.compare(this.getClass(), "Goes to previous character history", null, commandName, "previousCharacter")) {			if (currentChar<=0)				currentChar=historyTask.getNumberOfHistories(currentTaxa)-1;			else				currentChar--;			recalculateAllTraceOperators(true);		}		else if (checker.compare(this.getClass(), "Queries user about which character history to use", null, commandName, "chooseCharacter")) {			int ic=historyTask.queryUserChoose(currentTaxa, " to trace ");			if (MesquiteInteger.isCombinable(ic)) {				currentChar = ic;				recalculateAllTraceOperators(true);			}		}		else if (checker.compare(this.getClass(), "Sets which character history to use", "[history number]", commandName, "setCharacter")) {			pos.setValue(0);			int icNum = MesquiteInteger.fromString(arguments, pos);			if (!MesquiteInteger.isCombinable(icNum))				return null;			int ic = CharacterStates.toInternal(icNum);			if ((ic>=0) && (ic<=historyTask.getNumberOfHistories(currentTaxa)-1)) {				currentChar = ic;				recalculateAllTraceOperators(true);			}		}		else if (checker.compare(this.getClass(), "Sets which mapping to use", "[mapping number]", commandName, "setMapping")) {			pos.setValue(0);			int icNum = MesquiteInteger.fromString(arguments, pos);			if (!MesquiteInteger.isCombinable(icNum))				return null;			currentMapping = CharacterStates.toInternal(icNum);			recalculateAllTraceOperators(false);		}		else if (checker.compare(this.getClass(), "Returns the number of character histories available in the current character history source", null, commandName, "getNumberOfHistories")) {			return new MesquiteInteger(historyTask.getNumberOfHistories(currentTaxa));		}		else if (checker.compare(this.getClass(), "Turns off trace character", null, commandName, "closeTrace")) {			iQuit();			resetContainingMenuBar();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	public int getNumberOfHistories(Tree tree) {		return historyTask.getNumberOfHistories(tree);	}	/*.................................................................................................................*/	public int getNumberOfMappings(Tree tree) {		return historyTask.getNumberOfMappings(tree, currentChar);	}	/*.................................................................................................................*/	public void prepareHistory(Tree tree) {		int maxnum = historyTask.getNumberOfHistories(tree);		currentTaxa = tree.getTaxa();		if (currentChar>= maxnum)			currentChar = maxnum-1;		if (currentChar<0)			currentChar = 0;		historyTask.prepareHistory(tree, currentChar);		int nummap = historyTask.getNumberOfMappings(tree, currentChar);		if (currentMapping>= nummap)			currentMapping = nummap-1;		if (currentMapping<0)			currentMapping = 0;		lastCharRetrieved = currentChar;	}	/*.................................................................................................................*/	public CharacterHistory getMapping(Tree tree, MesquiteString resultString) {		CharacterHistory currentHistory = historyTask.getMapping(currentMapping, null, resultString);		return currentHistory;	}	/*.................................................................................................................*/	public int getNumberCurrentHistory() {		return CharacterStates.toExternal(currentChar);	}	/*.................................................................................................................*/	public int getNumberCurrentMapping() {		return CharacterStates.toExternal(currentMapping);	}	/*.................................................................................................................*/	public void employeeOutputInvalid(MesquiteModule employee, MesquiteModule source) {		blankAllTraceOperators();	}	/*.................................................................................................................*/	public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification) {		if (employee==historyTask) {			currentHistory = null;  // to force retrieval of new history			if (propWeight.isEnabled() != historyTask.allowsStateWeightChoice()){				propWeight.setEnabled(historyTask.allowsStateWeightChoice());				MesquiteTrunk.resetMenuItemEnabling();			}			recalculateAllTraceOperators(true);			resetAllTraceOperators();			parametersChanged(notification);		}		else {			resetAllTraceOperators();		}	}	/*.................................................................................................................*/	public void closeAllTraceOperators() {		if (traces==null)			return;		Enumeration e = traces.elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			if (obj instanceof TraceCharacterOperator) {				TraceCharacterOperator tCO = (TraceCharacterOperator)obj;				tCO.turnOff();			}		}	}	boolean Q = true;	/*.................................................................................................................*/	public void resetAllTraceOperators() {		if (traces==null)			return;		Enumeration e = traces.elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			if (obj instanceof TraceCharacterOperator) {				TraceCharacterOperator tCO = (TraceCharacterOperator)obj;				if (tCO.treeDisplay!=null)					tCO.treeDisplay.pleaseUpdate(Q);				if (tCO.traceLegend!=null)					tCO.traceLegend.repaint();			}		}	}	/*.................................................................................................................*/	public void resetFromScratchAllTraceOperators() {		if (traces==null)			return;		Enumeration e = traces.elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			if (obj instanceof TraceCharacterOperator) {				TraceCharacterOperator tCO = (TraceCharacterOperator)obj;				if (tCO.decorator!=null)					tCO.decorator.turnOff(); //why is this called?				tCO.decorator = null;				if (tCO.treeDisplay!=null)					tCO.treeDisplay.pleaseUpdate(true);				if (tCO.traceLegend!=null)					tCO.traceLegend.repaint();			}		}	}	/*.................................................................................................................*/	public void blankAllTraceOperators() {		if (traces==null)			return;		currentHistory = null;  // to force retrieval of new observedStates		Enumeration e = traces.elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			if (obj instanceof TraceCharacterOperator) {				TraceCharacterOperator tCO = (TraceCharacterOperator)obj;				if (tCO.traceLegend!=null)					tCO.traceLegend.setSpecsMessage("Calculating...");			}		}	}	/*.................................................................................................................*/	public void recalculateAllTraceOperators(boolean doPreps) {		if (traces==null || suspend)			return;		blankAllTraceOperators();		currentHistory = null;  // to force retrieval of new observedStates		Enumeration e = traces.elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			if (obj instanceof TraceCharacterOperator) {				TraceCharacterOperator tCO = (TraceCharacterOperator)obj;				tCO.doCalculations(doPreps);			}		}	}	/*.................................................................................................................*/	public void notifyIncorpModColorsAllTO() {		if (traces==null)			return;		Enumeration e = traces.elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			if (obj instanceof TraceCharacterOperator) {				TraceCharacterOperator tCO = (TraceCharacterOperator)obj;				tCO.incorporateModColors();				tCO.doCalculations(true);			}		}	}	/*.................................................................................................................*/	public void revertColorsAllTO() {		if (traces==null)			return;		Enumeration e = traces.elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			if (obj instanceof TraceCharacterOperator) {				TraceCharacterOperator tCO = (TraceCharacterOperator)obj;				tCO.revertColors();			}		}	}	/*.................................................................................................................*/	public void toggleReconstructAllTraceOperators() {		if (traces==null)			return;		Enumeration e = traces.elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			if (obj instanceof TraceCharacterOperator) {				TraceCharacterOperator tCO = (TraceCharacterOperator)obj;				tCO.toggleReconstruct();			}		}	}	/*.................................................................................................................*/	public void toggleLegendAllTraceOperators() {		if (traces==null)			return;		Enumeration e = traces.elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			if (obj instanceof TraceCharacterOperator) {				TraceCharacterOperator tCO = (TraceCharacterOperator)obj;				if (tCO.treeDisplay!=null)					tCO.treeDisplay.pleaseUpdate(Q);				if (tCO.traceLegend!=null)					tCO.traceLegend.setVisible(showLegend.getValue());			}		}	}	/*.................................................................................................................*/	public void endJob() {		closeAllTraceOperators();		super.endJob();	}	/*.................................................................................................................*/	public String getName() {		return "Trace Character History";	}	/*.................................................................................................................*/	public boolean showCitation(){		return true;	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	/*.................................................................................................................*/	public boolean isPrerelease(){		return false;	}	/*.................................................................................................................*/	/** returns whether this module is requesting to appear as a primary choice */	public boolean requestPrimaryChoice(){		return true;  	}	/*.................................................................................................................*/	public String getExplanation() {		return "Traces a history of character evolution on the nodes of a drawn tree.";	}}/* ======================================================================== */class TraceCharacterOperator extends TreeDisplayDrawnExtra implements CharHistoryContainer {	Tree myTree;	TraceCharacterHistory traceModule;	public TraceLegend traceLegend;	CharacterHistory history;	//private CharacterDistribution observedStates;	public TreeDecorator decorator;	private boolean holding = false;	boolean firstTime = true;	MesquiteColorTable colorTable = MesquiteColorTable.DEFAULTCOLORTABLE; 	public TraceCharacterOperator (TraceCharacterHistory ownerModule, TreeDisplay treeDisplay) {		super(ownerModule, treeDisplay);		traceModule = ownerModule;	}	public CharacterHistory getCharacterHistory(){		return history;	}	/*.................................................................................................................*/	public   void setTree(Tree tree){		myTree = tree;		if (tree!=null && (traceModule.historyTask!=null) && (traceModule.displayTask!=null) && !traceModule.suspend) {			if (traceLegend != null)				traceLegend.setSpecsMessage("Calculating...");			doCalculations(true);		}	}	/*.................................................................................................................*/	public void toggleReconstruct(){		if (traceLegend!=null)			traceLegend.reviseBounds();	}	/*.................................................................................................................*/	public   Tree getTree(){		return myTree;	}	/*.................................................................................................................*/	public   Taxa getTaxa(){		if (myTree !=null)			return myTree.getTaxa();		else			return null;	}	CharacterState state=null;	/*	void fillWithObserved(Tree tree, int node, CharacterHistory history, CharacterDistribution observed){		if (tree.nodeIsTerminal(node)){			state = observed.getCharacterState(state, tree.taxonNumberOfNode(node));			history.setCharacterState(node, state);		}		else {			state = observed.getCharacterState(state, 1); //merely to get an object to fill			state.setToUnassigned();			history.setCharacterState(node, state);		}		for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))				fillWithObserved(tree, daughter, history, observed);	}	 */	MesquiteString resultString = new MesquiteString();	/*.................................................................................................................*/	public void doCalculations(boolean doPreps) {		holding = true;		if (myTree == null) {		}		else {			traceModule.displayTask.onHold();			if (traceLegend==null  && traceModule.showLegend.getValue()) {				traceLegend = new TraceLegend(traceModule, this);				traceLegend.adjustScroll(traceModule.getNumberCurrentHistory(), traceModule.getNumberOfHistories(myTree)); 				traceLegend.adjustMappingScroll(traceModule.getNumberCurrentMapping(), traceModule.getNumberOfMappings(myTree)); 				addPanelPlease(traceLegend);			}			if (traceLegend!=null && traceModule.showLegend.getValue()) {				traceLegend.onHold();				traceLegend.adjustScroll(traceModule.getNumberCurrentHistory(), traceModule.getNumberOfHistories(myTree));				traceLegend.adjustMappingScroll(traceModule.getNumberCurrentMapping(), traceModule.getNumberOfMappings(myTree)); 			}			resultString.setValue("");			if (doPreps) {				traceModule.prepareHistory(myTree);			}			history = traceModule.getMapping(myTree, resultString);			if (history == null){				holding = false;				return;			}			MesquiteColorTable ct = colorTable;			colorTable = history.getColorTable(colorTable);			if (ct != colorTable && traceLegend != null)				for (int i = 0; i<64; i++)					for (int k= 0; k<64; k++)						traceLegend.modifiedColors[i][k] = false;			if (colorTable != null && colorTable.setColorEnabled() && !modColorsIncorporated && traceModule.whichColorsModified != null){				for (int box = 0; box<64; box++)					traceLegend.resetColor(traceModule.whichColorsModified[box], traceModule.newColors[box]);				modColorsIncorporated = true;			}			traceModule.displayTask.offHold();			holding = false;			treeDisplay.pleaseUpdate(firstTime);			firstTime = traceModule.Q;			if (traceLegend!=null && traceModule.showLegend.getValue()) {				traceLegend.offHold();				traceLegend.repaint();			}		}	}	void revertColors(){		for (int i = 0; i<64; i++)			for (int k= 0; k<64; k++)				traceLegend.modifiedColors[i][k] = false;		if (colorTable!= null && colorTable.setColorEnabled())			colorTable.resetToDefaults();		modColorsIncorporated = true;	}	boolean modColorsIncorporated = true;	public void incorporateModColors(){		modColorsIncorporated = false;	}	public void cursorEnterBranch(Tree tree, int N, Graphics g) {		if (traceModule.showLegend.getValue() && traceLegend!=null && history!=null)			traceLegend.setMessage(history.toString(N, "\n"));		if (treeDisplay != null)			treeDisplay.requestFocus();	}	public void cursorExitBranch(Tree tree, int N, Graphics g) {		if (traceModule.showLegend.getValue() && traceLegend!=null)			traceLegend.setMessage("");		if (treeDisplay != null)			treeDisplay.requestFocus();	}	public void cursorEnterTaxon(Tree tree, int M, Graphics g) {		if (traceModule.showLegend.getValue() && traceLegend!=null && history!=null && history.getObservedStates()!=null)			traceLegend.setMessage(history.getObservedStates().toString(M, "\n"));	}	public void cursorExitTaxon(Tree tree, int M, Graphics g) {		if (traceModule.showLegend.getValue() && traceLegend!=null)			traceLegend.setMessage("");	}	/*.................................................................................................................*/	public   void drawOnTree(Tree tree, int drawnRoot, Graphics g) {		if (!holding) {			if (traceModule.historyTask!=null) {				if (decorator==null)					decorator = traceModule.displayTask.createTreeDecorator(treeDisplay, this);				if (decorator==null)					return;				if (traceModule.useGray.getValue())					colorTable.setMode(MesquiteColorTable.GRAYSCALE);				else					colorTable.resetDefaultMode();				decorator.useColorTable(colorTable);				if (history !=null)					decorator.drawOnTree(tree, drawnRoot,  history, history.getObservedStates(), traceModule.showStateWeights, g); 				if (traceModule.showLegend.getValue()  && traceLegend!=null) {					if (history!=null) {						history.prepareColors(tree, drawnRoot);						traceLegend.setStates(history);					}					traceLegend.adjustLocation();					if (!traceLegend.isVisible())						traceLegend.setVisible(true);				}			}		}	}	public   void printOnTree(Tree tree, int drawnRoot, Graphics g) {		drawOnTree(tree, drawnRoot, g);	}	/**return a text version of information at node*/	public String textAtNode(Tree tree, int node){		if (history!=null)			return history.toString(node, ", ");		else			return null;	}	/**return a text version of any legends or other explanatory information*/	public String textForLegend(){		return resultString.getValue();	}	public void turnOff(){		if (decorator!=null) {			decorator.turnOff();			decorator = null;		}		if (traceLegend!=null && treeDisplay!=null){			removePanelPlease(traceLegend);			traceLegend = null;		}		super.turnOff();	}}/* ======================================================================== */class TraceLegend extends TreeDisplayLegend {	private TraceCharacterHistory traceModule;	public MiniScroll characterScroll = null;	public MiniScroll mappingScroll = null;	private TraceCharacterOperator tcOp;	private String[] stateNames;	private Color[] legendColors;	Point[] tableMappings;	boolean[][] modifiedColors;	private static final int defaultLegendWidth=142;	private static final int defaultLegendHeight=120;	private int numBoxes=0;	private int oldNumChars = 0;	private int oldNumMappings = 0;	private int oldNumBoxes=0;	private int oldCurrentChar = -1;	private int oldCurrentMapping = -1;	private boolean resizingLegend=false;	private TCMPanel messageBox;	private SpecsPrintTextArea specsBox;	private boolean holding = false;	int scrollAreaHeight = 41;	final int charScrollAreaHeight = 41;	final int mapScrollAreaHeight = 0;	private int messageHeight = 22;	final int defaultSpecsHeight = (14 + MesquiteModule.textEdgeCompensationHeight) * 3;	private int specsHeight = defaultSpecsHeight;	private int e = 4;	public TraceLegend(TraceCharacterHistory traceModule, TraceCharacterOperator tcOp) {		super(tcOp.treeDisplay,defaultLegendWidth, defaultLegendHeight, false);		setVisible(false);		legendWidth=defaultLegendWidth;		legendHeight=defaultLegendHeight;		if (MesquiteInteger.isCombinable(traceModule.initialLegendWidth))			legendWidth = traceModule.initialLegendWidth;		if (MesquiteInteger.isCombinable(traceModule.initialLegendHeight))			legendHeight = traceModule.initialLegendHeight;		setOffsetX(traceModule.initialOffsetX);		setOffsetY(traceModule.initialOffsetY);		this.tcOp = tcOp;		this.traceModule = traceModule;		setLayout(null);		setSize(legendWidth, legendHeight);		stateNames = new String[64];		legendColors = new Color[64];		tableMappings = new Point[64];		modifiedColors = new boolean[64][64];		for (int i=0; i<64; i++) {			stateNames[i] = null;			legendColors[i] = null;			tableMappings[i] = null;			for (int j=0; j<64; j++)				modifiedColors[i][j] = false;		}		specsBox = new SpecsPrintTextArea(" ", 2, 2, TextArea.SCROLLBARS_NONE);		specsBox.setEditable(false);		if (traceModule.showLegend.getValue())			specsBox.setVisible(false);		specsBox.setBounds(1,scrollAreaHeight +2,legendWidth-2, specsHeight);		messageBox = new TCMPanel();		int mTop = MesquiteInteger.maximum(legendHeight-messageHeight-8, scrollAreaHeight+2)+2;		int mHeight = MesquiteInteger.minimum(legendHeight-mTop-8, messageHeight);		messageBox.setBounds(2,mTop,legendWidth-6, mHeight);		messageBox.setText("\n");		try {			messageBox.setFocusTraversalKeysEnabled(false);		}		catch (Error e){		}		//messageBox.setColor(Color.pink);		//messageBox.setBackground(Color.pink);		add(messageBox);		add(specsBox);	}	public void adjustScroll(int currentCharExternal, int numChars) {		if (characterScroll == null) {			characterScroll = new MiniScroll( MesquiteModule.makeCommand("setCharacter",  (Commandable)traceModule), false, currentCharExternal, 1,  numChars,"character");			add(characterScroll);			characterScroll.setLocation(2,18);//18);			characterScroll.setColor(Color.blue);			repaint();			oldNumChars = numChars;			oldCurrentChar = currentCharExternal;		}		else {			if (oldNumChars != numChars) {				characterScroll.setMaximumValue(numChars);				oldNumChars = numChars;			}			if (oldCurrentChar != currentCharExternal) {				characterScroll.setCurrentValue(currentCharExternal);				oldCurrentChar = currentCharExternal;			}		}	}	public void adjustMappingScroll(int currentMappingExternal, int numMappings) {		if (mappingScroll == null) {			mappingScroll = new MiniScroll( MesquiteModule.makeCommand("setMapping",  (Commandable)traceModule), false, currentMappingExternal, 1,  numMappings,"mapping");			add(mappingScroll);			if (characterScroll != null)				mappingScroll.setLocation(characterScroll.getBounds().x + getBounds().width + 4,18 + charScrollAreaHeight);//18);			else				mappingScroll.setLocation(2,18 + charScrollAreaHeight);//18);			mappingScroll.setColor(Color.blue);			repaint();			oldNumMappings = numMappings;			oldCurrentMapping = currentMappingExternal;		}		else {			if (oldNumMappings != numMappings) {				mappingScroll.setMaximumValue(numMappings);				oldNumMappings = numMappings;			}			if (oldCurrentMapping != currentMappingExternal) {				mappingScroll.setCurrentValue(currentMappingExternal);				oldCurrentMapping = currentMappingExternal;			}		}		if (numMappings >1){			mappingScroll.setVisible(true);			scrollAreaHeight = charScrollAreaHeight + mapScrollAreaHeight;			checkComponentSizes();		}		else {			mappingScroll.setVisible(false);			scrollAreaHeight = charScrollAreaHeight;			checkComponentSizes();		}	}	public void checkComponentSizes(){		specsBox.setBounds(1,scrollAreaHeight+2,legendWidth-2, specsHeight);		specsBox.setVisible(true);		messageHeight = messageBox.getHeightNeeded();		if (messageHeight<20)			messageHeight = 20;		legendHeight=numBoxes*16+scrollAreaHeight + specsHeight + e + messageHeight + 4;		int mTop = MesquiteInteger.maximum(legendHeight-messageHeight-8, scrollAreaHeight+2) +2;		int mHeight = MesquiteInteger.minimum(legendHeight-mTop-8, messageHeight);		messageBox.setBounds(2,mTop,legendWidth-6, mHeight);		if (characterScroll != null)			mappingScroll.setLocation(characterScroll.getBounds().x + characterScroll.getBounds().width + 4,18);//18);		else			mappingScroll.setLocation(2,18 + charScrollAreaHeight);//18);	}	public void setVisible(boolean b) {		super.setVisible(b);		if (characterScroll !=null)			characterScroll.setVisible(b);		if (messageBox!=null)			messageBox.setVisible(b);		if (specsBox!=null)			specsBox.setVisible(b);	}	public void setLegendWidth(int w){		legendWidth = w;	}	public void setLegendHeight(int h){		legendHeight = h;	}	public int findBox(int x, int y) {		if (numBoxes!=0) {			for (int ibox=0; ibox<numBoxes; ibox++) {				int top = ibox*16+scrollAreaHeight + specsHeight+ e;				if (x >= 4 && y >= top && x <= 24 && y <= top +12)					return ibox;			}		}		return -1;	}	public void paint(Graphics g) {		if (MesquiteWindow.checkDoomed(this))			return;		if (!holding) {			g.setColor(Color.black);			if (numBoxes!=0) {				for (int ibox=0; ibox<numBoxes; ibox++) {					g.setColor(legendColors[ibox]);					g.fillRect(4, ibox*16+scrollAreaHeight + specsHeight+ e, 20, 12);					g.setColor(Color.black);					g.drawRect(4, ibox*16+scrollAreaHeight + specsHeight + e, 20, 12);					if (stateNames[ibox]!=null)						g.drawString(stateNames[ibox], 28, ibox*16 + specsHeight+scrollAreaHeight + 12 + e);				}			}			g.setColor(Color.cyan);			g.drawRect(0, 0, legendWidth-1, legendHeight-1);			g.fillRect(legendWidth-6, legendHeight-6, 6, 6);			g.drawLine(0, scrollAreaHeight, legendWidth-1, scrollAreaHeight);			g.setColor(Color.blue);			g.drawString("Trace Character", 4, 14);			if (mappingScroll.isVisible()){				if (characterScroll.isVisible())					g.drawString("Realization", 8 + characterScroll.getBounds().width + characterScroll.getBounds().x, 14);				else					g.drawString("Realization", 4 + 40, 14);			}			g.setColor(Color.black);			if (tcOp.resultString.getValue()!=null && !tcOp.resultString.getValue().equals(specsBox.getText())) {				specsBox.setText(tcOp.resultString.getValue()); 			}			if (specsBox.getBackground() != getBackground())				specsBox.setBackground(getBackground());		}		MesquiteWindow.uncheckDoomed(this);	}	public void print(Graphics g) {		if (MesquiteWindow.checkDoomed(this))			return;		if (!holding) {			int printHeight = legendHeight-1;			if (numBoxes!=0) 				printHeight = (numBoxes)*16+scrollAreaHeight + specsHeight + e;			g.setColor(Color.white);			g.fillRect(0, 0, legendWidth-1, printHeight);			g.setColor(Color.cyan);			g.drawRect(0, 0, legendWidth-1, printHeight);			g.setColor(Color.black);			String info = tcOp.resultString.getValue();			StringInABox sib = new StringInABox(info, g.getFont(), legendWidth);			sib.draw(g, 4, 4);			if (numBoxes!=0) {				for (int ibox=0; ibox<numBoxes; ibox++) {					g.setColor(legendColors[ibox]);					g.fillRect(4, ibox*16+scrollAreaHeight + specsHeight+ e, 20, 12);					g.setColor(Color.black);					g.drawRect(4, ibox*16+scrollAreaHeight + specsHeight + e, 20, 12);					if (stateNames[ibox]!=null)						g.drawString(stateNames[ibox], 28, ibox*16 + specsHeight+scrollAreaHeight + 12 + e);				}			}		}		MesquiteWindow.uncheckDoomed(this);	}	public void printOLD(Graphics g) {		g.setColor(Color.black);		g.drawString("Trace Character", 4, 14);		String info = tcOp.resultString.getValue();		StringInABox sib = new StringInABox(info, g.getFont(), legendWidth);		sib.draw(g, 4, 16);		int QspecsHeight = sib.getHeight();		int lastBox = QspecsHeight + 20;		if (numBoxes!=0) {			for (int ibox=0; ibox<numBoxes; ibox++) {				g.setColor(legendColors[ibox]);				g.fillRect(4, ibox*16+ QspecsHeight + 20, 20, 12);				g.setColor(Color.black);				g.drawRect(4, ibox*16+ QspecsHeight + 20, 20, 12);				g.drawString(stateNames[ibox], 28, ibox*16 + QspecsHeight + 32);				lastBox =ibox*16 + QspecsHeight + 20 + 12;			}		}	}	public void setStates(CharacterHistory statesAtNodes){		numBoxes = statesAtNodes.getLegendStates(legendColors, stateNames, tableMappings, tcOp.colorTable);		if (numBoxes!=oldNumBoxes) {			reviseBounds();			oldNumBoxes=numBoxes;		}		repaint();	}	/*-----------------------------*/	public String getModColorsCommand(){		String s = "modifyColors ";		boolean found = false;		for (int i = 0; i<64; i++){			for (int j = 0; j<64; j++){				if (modifiedColors[i][j]) {					Color c = tcOp.colorTable.getColorDirect(i, j);					if (c == null)						return null;					s += " " + i + " " + j + "  " + c.getRed() + " " + c.getGreen() + " " + c.getBlue();					found = true;				}			}		}		if (!found)			return null;		return s;	}	public void resetColor(Point tablePoint, Color color){		if (color != null && tcOp.colorTable.setColorEnabled()){			tcOp.colorTable.setColor(tablePoint.x, tablePoint.y, color);			modifiedColors[tablePoint.x][tablePoint.y] = true;			legendColors[tablePoint.y] = color;		}	}	/*-----------------------------*/	public void resetColor(int box){		if (tableMappings != null && box >= 0 && box <tableMappings.length){			Point tablePoint = tableMappings[box];			if (tablePoint != null){				if (!tcOp.colorTable.setColorEnabled()){					tcOp.ownerModule.alert("You aren't able to change the colors for this character");					return;				}				else if (tcOp.colorTable.getMode()==MesquiteColorTable.GRAYSCALE){					tcOp.ownerModule.alert("You can't change the gray scale colors");					return;				}				Color color = ColorDialog.queryColor(MesquiteWindow.windowOfItem(this), "Choose Color", "Color for state", tcOp.colorTable.getColor(tablePoint.x, tablePoint.y));				if (color != null){					tcOp.colorTable.setColor(tablePoint.x, tablePoint.y, color);					modifiedColors[tablePoint.x][tablePoint.y] = true;					legendColors[box] = color;					tcOp.treeDisplay.pleaseUpdate(true);					tcOp.traceModule.revertColorsItem.setEnabled(true);					MesquiteTrunk.resetMenuItemEnabling();					repaint();				}			}		}	}	public void mouseDown(int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		super.mouseDown(modifiers, clickCount, when, x, y, tool);		int box = findBox(x, y);		if (box >=0 && clickCount>=2)			resetColor(box);	}	public void legendResized(int widthChange, int heightChange){		if ((specsHeight + heightChange)>= defaultSpecsHeight)			specsHeight += heightChange;		else			specsHeight  = defaultSpecsHeight;		checkComponentSizes();	}	public void reviseBounds(){		checkComponentSizes();		Point where = getLocation();		setBounds(where.x,where.y,legendWidth, legendHeight);	}	public void setMessage(String s) {		if (s==null || s.equals("")) {			//messageBox.setBackground(ColorDistribution.light);			messageBox.setText("\n");			reviseBounds();		}		else {			//messageBox.setBackground(Color.white);			messageBox.setText(s);			reviseBounds();		}	}	public void setSpecsMessage(String s) {		if (s!=null) {			specsBox.setText(s);		}	}	public void onHold() {		holding = true;	}	public void offHold() {		holding = false;	}}class TCMPanel extends Panel {	String message = "";	StringInABox box;	public TCMPanel(){		super();		box =  new StringInABox("", null, getBounds().width);	}	public void setBounds(int x, int y, int w, int h){		super.setBounds(x,y,w,h);		box.setWidth(w);	}	public void setSize(int w, int h){		super.setSize(w,h);		box.setWidth(w);	}	public int getHeightNeeded(){		return box.getHeight() + 5;	}	public void paint (Graphics g) {		if (MesquiteWindow.checkDoomed(this))			return;		box.setFont(g.getFont());		box.draw(g,0, 0);		MesquiteWindow.uncheckDoomed(this);	}	public void setText(String s) {		message = s;		box.setString(s, getGraphics());		repaint();	}	public void print(Graphics g){	}	public void printAll(Graphics g){	}	public void printComponents(Graphics g){	}}class SpecsPrintTextArea extends TextArea {	public SpecsPrintTextArea(String s, int a, int b, int c){		super(s, a, b, c);	}	public void setText(String s){		super.setText(s);		try {			if (isVisible())				setCaretPosition(0);		}		catch (Exception e){		}	}}
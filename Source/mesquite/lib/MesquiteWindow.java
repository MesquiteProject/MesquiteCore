/* Mesquite source code.  Copyright 1997-2006 W. Maddison and D. Maddison.Version 1.11, June 2006.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)Modified May 02 especially for annotations*/package mesquite.lib;import java.awt.*;import java.awt.event.*;import java.util.*;import java.awt.datatransfer.*;import java.awt.print.*;import java.awt.geom.*;import java.io.*;import mesquite.lib.duties.*;/* ======================================================================== *//** A stand alone window ("Frame").  The modules do not add their components directly to this window, but ratherto special Containers within the window.  This is done to deal with the difficulties of sizing, because of insets in non-MacOS systems,given Mesquite's tendency to use null Layouts.  The first Component within the MesquiteWindow is the OuterContentsArea. Itcontains the InfoBar and the InterContentArea.  The InterContentArea contains a series of ContentAreas.  One of these, graphics[0]below, is the one to which a module should add any Components it needs to display (this is done by calling addToWindow()).  Theother ContentAreas are for textual information or Mesquite-controlled graphical information.*/public abstract class MesquiteWindow extends MesquiteFrame implements Listable, Commandable, OwnedByModule, FileDirtier, Logger {	LeakFinder leakFinder = MesquiteTrunk.leakFinderObject;//static Vector cd;	public MesquiteModule ownerModule;	public MesquiteMenuBar menuBar;	public static boolean suppressAllWindows = false; //for command line use; pass argument -w		public boolean resetMenuPending = false;	public int painting = 0;	public boolean disposing = false;	public static boolean autoShow = true;	public static MesquiteWindow activeWindow;	static int highestRank =0;	static int lowestRank =0;	int rank = -1;	private Object currentObject = null;	boolean minimalMenus = false;	public static boolean GUIavailable = true;	public static boolean Java2Davailable = true;	protected MesquiteCommand showCommand, showInfoBarCommand, saveAsTextCommand, printCommand, printToFitCommand;	protected MesquiteCommand setFontCommand, setFontSizeCommand, listEmployeesCommand, doMacroCommand, showExplanationsCommand;	protected MesquiteCommand showSnapshotCommand, sendScriptCommand, showFileCommand, closeWindowCommand;	protected MesquiteCommand printToPDFCommand;	public static boolean pdfOutputAvailable = true; 	protected Font currentFont;	public static Font defaultFont;		private MesquiteTool currentTool;	private ToolPalette palette;	private ExplanationArea explanationArea, annotationArea;	private Annotatable defaultAnnotatable;	int explanationHeight = 0;	int annotationHeight = 0;	public int tickled = 0;  //repaint control to deal with Jaguar bug; see surveyNewWindows in MesquiteThread	private int setSizeDebugg = 0;	private boolean wasDisposed = false;	private int menuResets = 0;	private static boolean reportMenuResets = false;	private int contentHeight = 0;	private int contentWidth = 0;	private OuterContentArea outerContents;	private InterContentArea interContents;	private ContentArea[] graphics;	protected TextContentArea[]  text;	protected InfoBar infoBar;	protected Cursor waitCursor, restoreCursor;	public int infoBarHeight = 0;	private boolean showInfoBar = true;	boolean queryMode = false;	protected MesquiteMenuItem cloneWindowMenuItem, saveRecipeMenuItem,explanationsMenuItem, snapshotMenuItem, sendScriptMenuItem, closeWindowMenuItem;	private MesquiteMenuItemSpec ptfMMIS;	private MesquiteMenuItemSpec pPDFMMIS;	MesquiteCheckMenuItem infoBarMenuItem;	private StringBuffer logText;	private int oldInsetTop, oldInsetBottom, oldInsetRight, oldInsetLeft;	public static Frame dialogAnchor;	public static MesquiteTimer startingTime, resetMenuTime, windowShowTime;	private MWWE mwwe;	public static int numDialogs=0;	static MenuShortcut closeWindowShortcut;	public static ClassVector componentsPainted; //for detecting efficiency problems	static {		startingTime = new MesquiteTimer();		windowShowTime = new MesquiteTimer();		resetMenuTime = new MesquiteTimer();				dialogAnchor = new Frame();		dialogAnchor.setBounds(-64, -64, 32,32);		closeWindowShortcut = new MenuShortcut(KeyEvent.VK_W);		defaultFont = new Font ("SanSerif", Font.PLAIN, 10); //added 5 Nov 01			}	/** a constructor not to be used except internally!!!  This is used for accumulating commands*/	public MesquiteWindow () {	}	/**the standard constructor for MesquiteWindows*/	public MesquiteWindow (MesquiteModule ownerModule, boolean showInfoBar) {			super();		/*following done for OS 9 because of crashing bug in MRJ 2.2.5 if application menu touched; also may help other OS's to establish insets early?? */		Menu fM = new MesquiteMenu("File");		MenuBar mBar = new MenuBar();		mBar.add(fM);		setMenuBar(mBar);				if (!GUIavailable)			System.out.println("Sorry, there is no GUI available (possibly because Mesquite is being run from a terminal).  Mesquite currently needs a GUI to function.");		this.ownerModule = ownerModule;		setForeground(Color.black);		startingTime.start();		this.showInfoBar = showInfoBar;		oldInsetTop=oldInsetBottom=oldInsetRight= oldInsetLeft= -1; 		setLayout(new CardLayout());		outerContents = new OuterContentArea(this);		add(outerContents, "Contents"); //"Contents"		outerContents.requestFocus(); //this may address a MRJ 2.2.3 bug		if (showInfoBar) 			infoBarHeight = 17;		else			infoBarHeight = 0;		waitCursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);		restoreCursor = Cursor.getDefaultCursor();				infoBar = new InfoBar(this);		outerContents.add(infoBar, "InfoBar"); //"InfoBar"		outerContents.setInfoArea(infoBar);				explanationArea = new ExplanationArea(this, false); 		outerContents.setExplanationArea(explanationArea);		outerContents.add(explanationArea, "ExplanationArea"); //"ExplanationArea"		explanationArea.setBackground(ColorDistribution.light[getColorScheme()]);		annotationArea = new ExplanationArea(this, true);		annotationArea.setBackground(Color.white);		outerContents.setAnnotationArea(annotationArea);		setAnnotation(null);		//windowAnnotation.addListener(this);		//defaultAnnotation = windowAnnotation;		outerContents.add(annotationArea, "AnnotationArea"); //"ExplanationArea"				interContents = new InterContentArea();		outerContents.add(interContents, "InterContents"); //"Contents"		graphics = new ContentArea[2];		graphics[0] = new ContentArea();   //this is the main graphics page				graphics[1] = new ETContentArea(ownerModule);   // this is the employee tree graphics page		interContents.addPage(graphics[0], Integer.toString(InfoBar.GRAPHICS)); // primary graphics page		interContents.addPage(graphics[1], Integer.toString(InfoBar.EMPLOYEE_TREE));		text = new TextContentArea[InfoBar.numModes];  //text pages		text[InfoBar.TEXT_CONTENTS] = new TextContentArea();		interContents.addPage(text[InfoBar.TEXT_CONTENTS], Integer.toString(InfoBar.TEXT_CONTENTS)); //strings correspond to modes		text[InfoBar.TEXT_PARAMETERS] = new TextContentArea();		interContents.addPage(text[InfoBar.TEXT_PARAMETERS], Integer.toString(InfoBar.TEXT_PARAMETERS)); //strings correspond to modes		text[InfoBar.TEXT_CITATIONS] = new TextContentArea();		interContents.addPage(text[InfoBar.TEXT_CITATIONS], Integer.toString(InfoBar.TEXT_CITATIONS)); //strings correspond to modes		outerContents.setContentsArea(graphics, text, interContents);		if (infoBar != null)			infoBar.setContentsArea(graphics, text, interContents);		outerContents.setSize(0,0);		interContents.showPage(InfoBar.GRAPHICS);		//if (isMainWindowOfBranch && ownerModule!=null)		//	ownerModule.window=this;		currentFont = defaultFont;		setWindowFont(currentFont);		setBackground(ColorDistribution.light[ColorDistribution.getColorScheme(ownerModule)]);		MesquiteTrunk.windowVector.addElement(this, true);		saveAsTextCommand = MesquiteModule.makeCommand("saveTextToFile",  this);		showCommand = MesquiteModule.makeCommand("showWindow",  this);		printCommand = MesquiteModule.makeCommand("printWindow",  this);		printToFitCommand = MesquiteModule.makeCommand("printToFit",  this);		if (Java2Davailable || this instanceof Fittable)			ptfMMIS = new MesquiteMenuItemSpec(null, "Print Window To Fit Page...", MesquiteModule.mesquiteTrunk, printToFitCommand);		printToPDFCommand = MesquiteModule.makeCommand("printToPDF", this);		if (Java2Davailable && pdfOutputAvailable)		    pPDFMMIS = new MesquiteMenuItemSpec(null,"Save Window As PDF...", MesquiteModule.mesquiteTrunk, printToPDFCommand);		setFontCommand =MesquiteModule.makeCommand("setFont",  this);		setFontSizeCommand =MesquiteModule.makeCommand("setFontSize",  this);		listEmployeesCommand = MesquiteModule.makeCommand("listEmployees",  this);		showInfoBarCommand = MesquiteModule.makeCommand("toggleInfoBar", this);		doMacroCommand =MesquiteModule.makeCommand("doMacro", this);		showFileCommand = MesquiteModule.makeCommand("showFile", ownerModule);		closeWindowCommand = MesquiteModule.makeCommand("closeWindow", this);		showExplanationsCommand =MesquiteModule.makeCommand("showExplanations", this);		showSnapshotCommand = MesquiteModule.makeCommand("showSnapshot", this);		sendScriptCommand = MesquiteModule.makeCommand("sendScript", this);		infoBarMenuItem = new MesquiteCheckMenuItem(new MesquiteCMenuItemSpec(null,"Show Information Bar", getOwnerModule(), showInfoBarCommand, null));		infoBarMenuItem.set(showInfoBar);		infoBarMenuItem.disconnectable = false;		explanationsMenuItem = new MesquiteMenuItem(new MesquiteMenuItemSpec(null,"Menu & Control Explanations", getOwnerModule(), showExplanationsCommand));		explanationsMenuItem.disconnectable = false;		cloneWindowMenuItem = new MesquiteMenuItem(new MesquiteMenuItemSpec(null, "Clone Window", getOwnerModule(), MesquiteModule.makeCommand("cloneWindow", this)));		cloneWindowMenuItem.disconnectable = false;		saveRecipeMenuItem = new MesquiteMenuItem(new MesquiteMenuItemSpec(null, "Save Window as Macro...", getOwnerModule(), MesquiteModule.makeCommand("saveMacroForWindow", this)));		saveRecipeMenuItem.disconnectable = false;		snapshotMenuItem = new MesquiteMenuItem(new MesquiteMenuItemSpec(null,"Show Snapshot", getOwnerModule(), showSnapshotCommand));		snapshotMenuItem.disconnectable = false;		sendScriptMenuItem = new MesquiteMenuItem(new MesquiteMenuItemSpec(null,"Send Script", getOwnerModule(), sendScriptCommand));		sendScriptMenuItem.disconnectable = false;		closeWindowMenuItem = new MesquiteMenuItem(new MesquiteMenuItemSpec(null, "Close Window", getOwnerModule(), closeWindowCommand));		closeWindowMenuItem.disconnectable = false;		closeWindowMenuItem.setShortcut(closeWindowShortcut);			menuBar = new MesquiteMenuBar(this);		//setMenuBar(menuBar);  //еее		setLocation(60, 10); //default window position		addComponentListener(new MWCE(this));				/* EMBEDDED if embedded remove this */		addWindowListener(mwwe = new MWWE(this));		/**/		addKeyListener(graphics[0], palette);		outerContents.requestFocus(); //this may address a MRJ 2.2.3 bug		startingTime.end();	}	/*.................................................................................................................*/	public MesquiteModule getOwnerModule() {		return ownerModule;	}	/*.................................................................................................................*/	/** For FileDirtier interface */	public void fileDirtiedByCommand(MesquiteCommand command){		if (ownerModule!=null && ownerModule.getProject()!=null && ownerModule.getProject().getHomeFile()!=null)			 ownerModule.getProject().getHomeFile().setDirtiedByCommand(true);	}	/*.................................................................................................................*/	public int getColorScheme(){		return ColorDistribution.getColorScheme(ownerModule);	}	/*.................................................................................................................*/	/** Shows information in response to query mode*/	public static void respondToQueryMode(String item, MesquiteCommand command, Object widget){			if (command!=null && widget !=null) {				MesquiteWindow w = null;				if (widget instanceof Component)					w = windowOfItem((Component)widget);				else if (widget instanceof MenuComponent)					w = windowOfItem((MenuComponent)widget);				if (w==null)					return;				MesquiteTrunk.mesquiteTrunk.showLogWindow(false);				String s = CommandChecker.getQueryModeString(item, command, widget);				w.setExplanation(s);			}	}	/*.................................................................................................................*/	/** Returns where the MesquiteWindow containing the component is in queryMode.  Returns false if not contained in a MesquiteWindow.	NOTE: this system was built in 2000 when the info bar had a ? button to turn on query mode.  Now (Jan 2001) that that's gone, and now that there is	an explanation area at the bottom of windows, an alternative systems were developed for explaining items on the fly (including control-select for menu items).	These query mode methods are left here in case it makes sense to resurrect them*/	public static boolean getQueryMode(Component c){		if (c==null)			return false;		if (c instanceof MesquiteWindow)			return ((MesquiteWindow)c).queryMode;				Container cont = c.getParent();		while (cont!= null && !(cont instanceof MesquiteWindow))			cont = cont.getParent();		if (cont instanceof MesquiteWindow)			return ((MesquiteWindow)cont).queryMode;		else 			return false;	}	/*.................................................................................................................*/	/** Returns where the MesquiteWindow containing the menu item is in queryMode.  Returns false if not contained in a MesquiteWindow.	NOTE: this system was built in 2000 when the info bar had a ? button to turn on query mode.  Now (Jan 2001) that that's gone, and now that there is	an explanation area at the bottom of windows, an alternative systems were developed for explaining items on the fly (including control-select for menu items).	These query mode methods are left here in case it makes sense to resurrect them*/	public static boolean getQueryMode(MenuComponent c){		MesquiteWindow win = windowOfItem(c);		if (win!=null)				return win.queryMode;		return false;	}	/*.................................................................................................................*/	/** Returns the MesquiteWindow containing the menu item*/	public static MesquiteWindow windowOfItem(MenuComponent c){		if (c==null)			return null;		if (c instanceof MenuBar)			return getWindow((MenuBar)c);		if (!(c instanceof MenuComponent))			return null;		MenuContainer cont = ((MenuComponent)c).getParent();		while (cont!= null && !(cont instanceof MenuBar) && !(cont instanceof MesquitePopup)&& cont instanceof MenuComponent)			cont =  ((MenuComponent)cont).getParent();		if (cont instanceof MenuBar) {			return getWindow((MenuBar)cont);		}		else if (cont instanceof MesquitePopup){			return windowOfItem(((MesquitePopup)cont).getComponent());		}		return null;	}	private static MesquiteWindow getWindow(MenuBar mb){		if(mb==null)			return null;			 		Enumeration e = MesquiteTrunk.windowVector.elements(); 		while (e.hasMoreElements()) {			Object obj = e.nextElement();			MesquiteWindow mw = (MesquiteWindow)obj;	 		if (mw.getMenuBar()==mb)	 			return mw; 		} 		return null;	 			}	/*.................................................................................................................*/	/** Returns the MesquiteWindow containing the component.  Returns null if not contained in a MesquiteWindow*/	public static MesquiteWindow windowOfItem(Component c){		if (c==null)			return null;		if (c instanceof MesquiteWindow)			return (MesquiteWindow)c;				Container cont = c.getParent();		while (cont!= null && !(cont instanceof MesquiteWindow))			cont = cont.getParent();		if (cont instanceof MesquiteWindow)			return (MesquiteWindow)cont;		else 			return null;	}	/*.................................................................................................................*/	/** Returns the Frame containing the component.  Returns null if not contained in a Frame*/	public static Frame frameOfComponent(Frame c){			return c;	}	/*.................................................................................................................*/	/** Returns the Frame containing the component.  Returns null if not contained in a Frame*/	public static Frame frameOfComponent(Component c){		if (c==null)			return null;		if (c instanceof Frame)			return (Frame)c;				Container cont = c.getParent();		while (cont!= null && !(cont instanceof Frame))			cont = cont.getParent();		if (cont instanceof Frame)			return (Frame)cont;		else 			return null;	}static boolean checkcheck = false;static long checkedCount = 0;static Component lastComponent = null;static boolean writeUnchecked = false;public static long totalCheckDoomedCount = 0;	/*.................................................................................................................*/	/** Returns whether the window belongs to a doomed module (one about to be closed).  To be called at the start of all	paint methods to abort the paint.  At the same time, this method sets a flag in the window to say that painting is in progress.	While this flag is set, the window will not be disposed.  The method uncheckDoomed(Component c) must be called at the end of the paint*/	public static boolean checkDoomed(Component c){ //System.out.println("* checkDoomed " + c);		totalCheckDoomedCount++;		if (c!=null && componentsPainted!=null)			componentsPainted.recordWithTime(c.getClass());		if (checkcheck){			if (c == lastComponent){				checkedCount++;				if (checkedCount % 100 == 0) {					MesquiteFile.writeToLog("checkDoomed " + checkedCount + "  " + c + StringUtil.lineEnding());					writeUnchecked = true;				}			}			else {				checkedCount =1;				writeUnchecked = true;			}			lastComponent = c;		}		MesquiteWindow w = null;		if (c instanceof Frame){//EMBEDDED : needs to be changed			if (c instanceof MesquiteWindow)				w = (MesquiteWindow)c;			else {				return false;			}		}		else {			Container cont = c.getParent();			while (cont!= null && !(cont instanceof Frame))				cont = cont.getParent();			if (cont instanceof MesquiteWindow)				w = (MesquiteWindow)cont;			else if (!(cont instanceof Frame))				return true;			else  {				return false;			}		}		if (w==null) {			return false;		}//MesquiteFile.writeToLog("         checkDoomed window " + w + StringUtil.lineEnding());		if (w.getOwnerModule()!=null && (w.getOwnerModule().isDoomed() || w.disposing)) {			return true;		}//cd.addElement(c);		w.painting++;		return false;	}	/*.................................................................................................................*/	public static void uncheckDoomed(Component c){		MesquiteWindow w = windowOfItem(c);		if (c!=null && componentsPainted!=null)			componentsPainted.stopTime(c.getClass());		if (checkcheck && writeUnchecked && c == lastComponent) {			MesquiteFile.writeToLog("         uncheckDoomed " + c + StringUtil.lineEnding());		}		if (MesquiteTrunk.isMacOSXJaguar())			Toolkit.getDefaultToolkit().sync();		if (w==null) 			return;		w.painting--;	}		/*--------------------------------PAINT/PRINT/SAVETEXT contents ----------------------------------*/	public void contentsChanged() {		repaint();		if (disposing)			return;		if (graphics==null || graphics[0]==null || graphics[1]==null)			return;		if (infoBar!=null&& infoBar.getMode()>0) 			updateTextPage();	}	public void repaint() {		super.repaint();		if (disposing)			return;		if (graphics==null || graphics[0]==null || graphics[1]==null)			return;		if (infoBar==null)			graphics[0].repaint();		else if (infoBar.getMode()==InfoBar.GRAPHICS)			graphics[0].repaint();		else if (infoBar.getMode()==InfoBar.EMPLOYEE_TREE)			graphics[1].repaint();		if (showInfoBar)			infoBar.repaint();	}	/*.................................................................................................................*/	/** calls repaint of all components*/	public void repaintAll() {		if (infoBar.getMode()==InfoBar.GRAPHICS) {			rpAll(graphics[0]);			rpAll(palette);			rpAll(explanationArea);			rpAll(annotationArea);		}	}	private void rpAll(Component c){		if (c==null)			return;		c.repaint();		if (c instanceof Container){			Component[] cc = ((Container)c).getComponents();			if (cc!=null && cc.length>0)				for (int i=0; i<cc.length; i++)					rpAll(cc[i]);		}			}	/*.................................................................................................................*/	/** to be overridden by MesquiteWindows instead of paint to draw their contents*/	public void paintContents(Graphics g) {	}	/*.................................................................................................................*/	public void paint(Graphics g) {		if (checkInsets())			super.paint(g);	}	/*...............................................................................................................*/	/** set the cursor to be the wait cursor.*/	public void setGraphicsWaitCursor() {		restoreCursor = getCursor();		setGraphicsCursor(waitCursor);	}	/*...............................................................................................................*/	/** set the cursor to be the default cursor.*/	public void setGraphicsDefaultCursor() {		restoreCursor = getCursor();		setGraphicsCursor(Cursor.getDefaultCursor());	}	/*...............................................................................................................*/	protected void setContentsCursor(Cursor c){		graphics[0].setCursor(c);	}	/*...............................................................................................................*/	/** set the cursor to be that passed.*/	public void setGraphicsCursor(Cursor c) {		restoreCursor = getCursor();		if (c!=null)			setContentsCursor(c);	}	/*...............................................................................................................*/	/** restores the cursor to previous.*/	public void restoreGraphicsCursor() {		if (restoreCursor!=null)			setContentsCursor(restoreCursor);		restoreCursor = null;	}	/*...............................................................................................................*/	/** restores the cursor of all windows to previous.*/	public static void restoreAllCursors() {		Enumeration e = MesquiteModule.mesquiteTrunk.windowVector.elements(); 		while (e.hasMoreElements()) {			MesquiteWindow win = (MesquiteWindow)e.nextElement();			win.restoreGraphicsCursor(); 		}	}	/*...............................................................................................................*/	/** restores the cursor of all windows to wait cursor.*/	public static void setAllWaitCursors() {		Enumeration e = MesquiteModule.mesquiteTrunk.windowVector.elements(); 		while (e.hasMoreElements()) {			MesquiteWindow win = (MesquiteWindow)e.nextElement();			win.setGraphicsWaitCursor(); 		}	}	/*.................................................................................................................*/	/** to be called to update the current text page's contents*/	public final void updateTextPage() {		if (infoBar!=null)		for (int i=1; i<InfoBar.numModes; i++)			infoBar.refreshText(i);	}	/*.................................................................................................................*/	/** Update the page showing the employee tree (to be called after employees added or	subtracted)  */	public void updateEmployeeTree(){		if (graphics[1] instanceof ETContentArea) {			HPanel b = ((ETContentArea)graphics[1]).getBrowser();			if (b!=null)				b.renew();		}	}	/*.................................................................................................................*/	/** to be overridden by MesquiteWindows for a text version of their contents*/	public String getTextContents() {		return "Sorry, there is not a text version of this window's contents";	}	boolean w = false;	/*.................................................................................................................*/	/** saves text file with contents of window*/	public String saveTextToFile(String path, boolean append) {		while (w)			;		w = true;		String result = getTextContents();		if (append)			MesquiteFile.appendFileContents(path, result, false);		else			MesquiteFile.putFileContents(path, result, false);		w = false;		return result;	}		/** Returns menu location for item to bring the window to the for (0 = custom or don't show; 1 = system area of Windows menu; 2 = after system area of Windows menu)*/	public int getShowMenuLocation(){		return 2;	}	/*.................................................................................................................*/	/** To be overridden to provide more appropriate print menu item (e.g., "Print Tree...", "Print Chart..."*/	public String getPrintMenuItem() {		return "Print Window...";	}	/*.................................................................................................................*/	/** To be overridden to provide more appropriate print menu item (e.g., "Print Tree To Fit Page...", "Print Chart To Fit Page..."*/	public String getPrintToFitMenuItemName() {		return "Print Window To Fit Page...";	}	/*.................................................................................................................*/	MesquiteMenuItemSpec getPrintToFitMenuItem() {		if (ptfMMIS!=null)			ptfMMIS.setName(getPrintToFitMenuItemName());		return ptfMMIS;	}	/*.................................................................................................................*/	/** To be overridden to provide more appropriate print menu item (e.g., "Print Tree to PDF...", "Print Chart..."*/	public String getPrintToPDFMenuItemName() {		return "Save Window as PDF...";	}		/*.................................................................................................................*/	MesquitePrintJob pjob;	/** Prints the current display in the window.  To be overridden to print in any special way.*/	public void printWindow(MesquitePrintJob pjob) { 		if (pjob != null) {			int mode;			if (infoBar==null)				mode =InfoBar.GRAPHICS;			else mode = infoBar.getMode();			if (mode==InfoBar.GRAPHICS || mode == InfoBar.EMPLOYEE_TREE) {//graphical mode 				if (mode==InfoBar.GRAPHICS)					pjob.printComponent(graphics[0], null, currentFont); 				else					pjob.printComponent(graphics[1], null, currentFont); 			}			else if (infoBar!=null){  //text mode								String s = infoBar.getText(mode);				pjob.printText(s, new Font("Monospaced", Font.PLAIN, 12));			} 		}	}	/*.................................................................................................................*/	/** Print the parameters of the current module output. */	public final void printParameters(MesquitePrintJob pjob) { 		if (pjob != null && infoBar!=null) {			String s = infoBar.getText(InfoBar.TEXT_PARAMETERS);			pjob.printText(s, getFont()); 		}	}		/*.................................................................................................................*/	private void openPrWindow(int fitToPage) {		Frame f = this.getTheWindow();		if (!(f instanceof MesquiteWindow))			return; 		int fitRule; 		if (infoBar.getMode()!= InfoBar.GRAPHICS) 			fitRule = MesquitePrintJob.AUTOFIT; 		else 			fitRule = fitToPage;		pjob = MesquitePrintJob.getPrintJob((MesquiteWindow)f, "Print Window", fitRule);	}	/*.................................................................................................................*/	private void doPrWindow() { 		if (pjob != null) {			printWindow(pjob); 		}	}	/*.................................................................................................................*/	private void closePrWindow() { 		if (pjob != null) { 			pjob.end(); 		}	}		//for java 1.1 printing	public Object getFitPrintObject(){		return null;	}	/*.................................................................................................................*/	protected void prWindow(int fitToPage) {		Frame f = this.getTheWindow();		if (!(f instanceof MesquiteWindow))			return; 		MainThread.setShowWaitWindow(false); 		int fitRule; 		if (infoBar.getMode()!= InfoBar.GRAPHICS) 			fitRule = MesquitePrintJob.AUTOFIT; 		else 			fitRule = fitToPage;		pjob = MesquitePrintJob.getPrintJob((MesquiteWindow)f, "Print Window", fitRule); 		if (pjob != null) { 			MesquiteTrunk.mesquiteTrunk.logln("Printing window");			printWindow(pjob);			/*			if (infoBar !=null && infoBar.getMode()!=InfoBar.TEXT_PARAMETERS)				printParameters(pjob); 			*/ 			pjob.end();		}		MainThread.setShowWaitWindow(true);	}	/*.................................................................................................................*/	MesquitePDFFile pdfFile;	/**	Writes the current display in the window to a PDF file.  To be overridden to display in any special way.	@author Peter Midford	*/	public void windowToPDF(MesquitePDFFile pdfFile, int fitToPage) { 		if (pdfFile != null) {			int mode;	 		int fitRule = fitToPage;     //move fitRule here so it can be overridden			pdfFile.setSizeOrientation(fitRule);        //will prompt for a size 			//if (infoBar.getMode()!= InfoBar.GRAPHICS) 			//	fitRule = MesquitePrintJob.AUTOFIT; 			//else 			//	fitRule = MesquitePrintJob.AUTOFIT; //fitToPage;			if (infoBar==null)				mode = InfoBar.GRAPHICS;			else mode = infoBar.getMode();			if (mode==InfoBar.GRAPHICS || mode == InfoBar.EMPLOYEE_TREE) {//graphical mode				Component printingComponent; 				if (mode==InfoBar.GRAPHICS)  					printingComponent = graphics[0]; 				else 					printingComponent = graphics[1]; 				pdfFile.printComponent(printingComponent,null,currentFont); 				//TODO: figure out why calling print(g) generates empty pages.				//Graphics g = pdfFile.getPDFGraphicsForComponent(printingComponent, null);				//printingComponent.print(g);				//pdfFile.end(); 			}			else if (infoBar!=null){  //text mode					String s = infoBar.getText(mode);				//Changed font size to 10, since courier is the only adobe supplied monospace font and				//it is a little larger than the system supplied monospace font.				pdfFile.printText(s, new Font("Monospaced", Font.PLAIN, 10));			}		}			}		/*.................................................................................................................*/	/**	@author Peter Midford	@param fitToPage int no longer used; PDF will always fit to one page; user can edit the file if necessary 	*/	protected void pdfWindow(int fitToPage) {		Frame f = this.getTheWindow();		if (!(f instanceof MesquiteWindow))			return; 		MainThread.setShowWaitWindow(false); 		pdfFile = MesquitePDFFile.getPDFFile((MesquiteWindow)f, "Save Window to PDF"); 		if (pdfFile != null) {			windowToPDF(pdfFile, fitToPage);		}		MainThread.setShowWaitWindow(true);	}		/*--------------------------------MODE (GRAPHICS, TEXT, INFO.) ----------------------------------*/	/*.................................................................................................................*/	/** The method to be called to add a component for display (adds it to the graphics[0] content area) */	public Component addToWindow(Component c) {		if (currentTool!=null) {			removeKeyListener(graphics[0], currentTool);		}		removeKeyListener(graphics[0], palette);		Component cc =  graphics[0].add(c);		if (currentTool!=null) {			addKeyListener(graphics[0], currentTool);		}		addKeyListener(graphics[0], palette);		return cc;	}	/*.................................................................................................................*/	/** The method to be called to remove a component from display (removes if from the graphics[0] content area) */	public void removeFromWindow(Component c) {		if (currentTool!=null) {			removeKeyListener(graphics[0], currentTool);		}		removeKeyListener(graphics[0], palette);		if (graphics[0] !=null)			graphics[0].remove(c);		if (currentTool!=null) {			addKeyListener(graphics[0], currentTool);		}		addKeyListener(graphics[0], palette);	}	/*.................................................................................................................*/	/** Called in some circumstances (not all) when a component is added to a container in the window.  Currently used so that	the Tree window knows that a component has been added to the TreeDisplay.*/	public void componentAdded(Container cont, Component comp){	}	/*.................................................................................................................*/	/** Causes the main graphics area to request focus*/	public void graphicsRequestFocus() {		if (graphics[0] !=null)		graphics[0].requestFocus();	}	/*.................................................................................................................*/	/** Gets the main graphics content area in which modules can add their components */	public Panel getGraphicsArea() {		if (graphics[0] != null)		return graphics[0].getMainPanel();		return null;	}	/** requests that a side panel be added to main graphics panel */	public void addSidePanel(MousePanel sp, int width) {		if (graphics[0] != null)		 graphics[0].addSidePanel(sp, width);	}	/** requests that a side panel be added to main graphics panel */	public void removeSidePanel(MousePanel sp) {		if (graphics[0] != null)			graphics[0].removeSidePanel(sp);	}	/** requests that a ledge panel be added to main graphics panel */	public void addLedgePanel(MousePanel sp, int width) {		if (graphics[0] != null)		 graphics[0].addLedgePanel(sp, width);	}	/** requests that a side panel be added to main graphics panel */	public void removeLedgePanel(MousePanel sp) {		if (graphics[0] != null)		 graphics[0].removeLedgePanel(sp);	}	/*.................................................................................................................*/	/** Sets the palette of the main graphics content area */	private void setPalette(ToolPalette palette) {		if (graphics[0] == null)			return;		this.palette = palette;		graphics[0].setPalette(palette); //setting palette into main graphics page		addKeyListener(graphics[0], palette);	}	/*.................................................................................................................*/	/** Gets the tool palette of the main graphics content area */	public ToolPalette getPalette() {		return palette;	}	/*.................................................................................................................*/	public static void addKeyListener(Component c, KeyListener k){		if (c==null || k == null)			return;		c.addKeyListener(k);		if (c instanceof Container){			Component[] cc = ((Container)c).getComponents();			if (cc!=null && cc.length>0)				for (int i=0; i<cc.length; i++)					addKeyListener(cc[i], k);		}			}	/*.................................................................................................................*/	public static void removeKeyListener(Component c, KeyListener k){		if (c==null || k == null)			return;		c.removeKeyListener(k);		if (c instanceof Container){			Component[] cc = ((Container)c).getComponents();			if (cc!=null && cc.length>0)				for (int i=0; i<cc.length; i++)					removeKeyListener(cc[i], k);		}			}	/*.................................................................................................................*/	public void resetCursor(){  //May 02		if (currentTool == null || currentTool.getOnlyWorksWhereSpecified()){			setGraphicsDefaultCursor();			return;		}		Cursor c = currentTool.getCursor();		if (c!=null){			setGraphicsCursor(c);			if (palette!=null)				palette.repaintAll();  //a workaround for Windows Java VM bug?		}		else			setGraphicsDefaultCursor();	}	/*.................................................................................................................	public void resetCursor(){  //May 02		if (currentTool == null){			setGraphicsDefaultCursor();			return;		}		try { //just in case Java2 not available			Image im = currentTool.getCursorImage();			if (im == null){				Dimension best = getToolkit().getBestCursorSize(16, 16);				if ((best.width>16 || best.height>16) && MesquiteFile.fileExists(currentTool.getSizedImagePath(best.width))){					im = MesquiteImage.getImage(currentTool.getSizedImagePath(best.width));					if (im == null)						im = MesquiteImage.getImage(currentTool.getImagePath());				}				else 					im = MesquiteImage.getImage(currentTool.getImagePath());				currentTool.setCursorImage(im);			}			Cursor c = getToolkit().createCustomCursor(im, currentTool.getHotSpot(), currentTool.getName());			if (c!=null){				setGraphicsCursor(c);				if (palette!=null)					palette.repaintAll();  //a workaround for Windows Java VM bug?			}		}		catch (Throwable t){			setGraphicsDefaultCursor();		}	}		/*.................................................................................................................*/	public void setCurrentTool(MesquiteTool tool){		if (tool!=null && !tool.getEnabled())			return;		if (currentTool !=null) {			currentTool.setInUse(false);			removeKeyListener(graphics[0], currentTool); 		}  	 	currentTool = tool;		addKeyListener(graphics[0], currentTool); 		setExplanation("");		if (currentTool !=null) {			currentTool.setInUse(true);			if (currentTool.getDescription()!= null){				if (currentTool.getExplanation()==null || currentTool.getDescription().equals(currentTool.getExplanation()))					setExplanation("Tool: " + currentTool.getDescription());				else					setExplanation("Tool: " + currentTool.getDescription() + "\n(" +currentTool.getExplanation() + ")");			}			resetCursor();		}	}	/*.................................................................................................................*/	public MesquiteTool getCurrentTool(){		return currentTool;	}		protected ToolPalette makeToolPalette(){		return new ToolPalette(ownerModule, this, 1);	}	/*.................................................................................................................*/	public MesquiteButton addTool(MesquiteTool tool){  	 	if (palette==null) {  	 		setPalette(makeToolPalette()); //note default of 1			palette.setEnabled(true);  	 		palette.setVisible(true);  	 	}  	 	return palette.addTool(tool);	}	/*.................................................................................................................*/	public void removeTool(MesquiteTool tool){  	 	if (palette !=null)  	 		palette.removeTool(tool);	}	/*.................................................................................................................*/	public void toolTextChanged(){  	 	if (palette !=null)  	 		palette.toolTextChanged(); //fixed Apr 02	}	/*.................................................................................................................*/	/** Gets the visibility of the InfoBar */	public boolean getShowInfoBar() {		return showInfoBar;	}	/*.................................................................................................................*/	/** Sets the visibility of the InfoBar */	public void setShowInfoBar(boolean vis) {		int h = getHeight();		showInfoBar = vis;		if (infoBar==null && vis){			infoBar = new InfoBar(this);			outerContents.add(infoBar, "InfoBar"); //"InfoBar"			outerContents.setInfoArea(infoBar);			infoBar.setContentsArea(graphics, text, interContents);		}		if (showInfoBar) 			infoBarHeight = 17;		else			infoBarHeight = 0;		setWindowSize(getFullWidth(),h);		showPage(InfoBar.GRAPHICS);		if (infoBarMenuItem !=null)			infoBarMenuItem.set(showInfoBar);	}	/*.................................................................................................................*/	/** Gets the visibility of the explanation area */	public boolean getShowExplanation() {		return explanationHeight != 0;	}	/*.................................................................................................................*/	/** Sets the visibility of the explanation area */	public void setShowExplanation(boolean vis) {		setShowExplanation(vis, ExplanationArea.minimumHeightExplanation);	}	/*.................................................................................................................*/	/** Gets the height of the explanation area */	public int getExplanationHeight() {		return explanationHeight;	}	/*.................................................................................................................*/	/** Sets the visibility of the explanation area */	public void setShowExplanation(boolean vis, int height) {		int h = getHeight();		int w = getFullWidth();		if (vis) 			explanationHeight = height;		else			explanationHeight = 0;		setWindowSize(w,h);	}	/*.................................................................................................................*/	/** Increments the height of the explanation area */	public void incrementExplanationArea() {		explanationArea.plus();	}	/*.................................................................................................................*/	/** Increments the height of the annotation area */	public void incrementAnnotationArea() {		annotationArea.plus();	}	/*.................................................................................................................*/	/** Gets the text in the explanation area.  This text is not editable */	public String getExplanation(){		if (explanationArea!=null) {			return explanationArea.getExplanation();		}		return null;	}	/*.................................................................................................................*/	/** Gets the visibility of the Annotation area */	public boolean getShowAnnotation() {		return annotationHeight != 0;	}	/*.................................................................................................................*/	/** Sets the visibility of the Annotation area */	public void setShowAnnotation(boolean vis) {		setShowAnnotation(vis, ExplanationArea.minimumHeightAnnotation);	}	/*.................................................................................................................*/	/** Gets the height of the Annotation area */	public int getAnnotationHeight() {		return annotationHeight;	}	/*.................................................................................................................*/	/** Sets the visibility of the Annotation area */	public void setShowAnnotation(boolean vis, int height) {		int h = getHeight();		int w = getFullWidth();		if (vis) 			annotationHeight = height;		else			annotationHeight = 0;		setWindowSize(w,h);	}		/*.................................................................................................................*/	/** Returns whether annotation area has input focus */	public boolean annotationHasFocus(){		if (annotationArea!=null) {			return annotationArea.hasFocus;		}		return false;	}	/*.................................................................................................................*/		/** Set the text in the explanation area.  This text is not editable */	public String getAnnotation(){		if (annotationArea!=null) {			return annotationArea.getExplanation();		}		return null;	}	/*.................................................................................................................*/	/** Sets the text in the explanation area.  This text is not editable */	public void setExplanation(String text){		if (explanationArea!=null) {			explanationArea.setExplanation(text);		}	}	/*.................................................................................................................*/	/** Sets the Annotatable whose annotation will be used for the default text in the annotation area.  */	public void setDefaultAnnotatable(Annotatable annot) {		defaultAnnotatable = annot;	}			/*.................................................................................................................*/	/** Sets whether the explanation and annotation areas can receive focus.*/	public void setAEFocusSuppression(boolean suppress){		if (annotationArea!=null)				annotationArea.setFocusSuppression(suppress);		if (explanationArea!=null)				explanationArea.setFocusSuppression(suppress);	}	/*.................................................................................................................*/	/** Sets the text in the annotation area.  This text is editable; changes will be made in the MesquiteString object itself */	public void setAnnotation(Annotatable annot){		if (annotationArea!=null) {			if (annot != null) {				annotationArea.setExplanation(annot); 				if (StringUtil.blank(annot.getName()))					setExplanation("");				else					setExplanation("Footnote above refers to " + annot.getName());			}			else if (defaultAnnotatable !=null) {				annotationArea.setExplanation(defaultAnnotatable);				if (StringUtil.blank(defaultAnnotatable.getName()))					setExplanation("");				else					setExplanation("Footnote above refers to " + defaultAnnotatable.getName());			}			else {				annotationArea.setExplanation("");				setExplanation("");			}		}	}	/*.................................................................................................................*/	/** Sets the text in the annotation area.  This text is not editable */	public void setAnnotation(String text, String annotationExplanation){		if (annotationArea!=null) {			if (StringUtil.blank(text)) {				annotationArea.setExplanation("");				setExplanation(annotationExplanation);			}			else {				annotationArea.setExplanation(text);				setExplanation(annotationExplanation);			}		}	}	/*.................................................................................................................*/	/** passes which object changed, along with optional code number (type of change) and integers (e.g. which character)*/	public void changed(Object caller, Object obj, Notification notification, CommandRecord commandRec){			}	/** passes which object was disposed*/	public void disposing(Object obj){	}	/** Asks whether it's ok to delete the object as far as the listener is concerned (e.g., is it in use?)*/	public boolean okToDispose(Object obj, int queryUser){		return true;	}	/*.................................................................................................................*/	/** Return main object displayed.  Usage is specific to subclasses (see especially ListWindows)*/	public Object getCurrentObject(){		return currentObject;	}		/*.................................................................................................................*/	/** Sets the main object displayed.  Usage is specific to subclasses (see especially ListWindows)*/	public void setCurrentObject(Object object){		currentObject = object;	}	/*.................................................................................................................*/	boolean temp;	/*.................................................................................................................*/	/** Requests the page to be displayed (see InfoBar) */	public void showPage(int mode) {		if (mode>=0 && mode<InfoBar.numModes) {			interContents.showPage(mode);		}		if (ptfMMIS!=null) {			ptfMMIS.setEnabled(mode == InfoBar.GRAPHICS);			MesquiteTrunk.resetMenuItemEnabling();		}	}	/*.................................................................................................................*/	/** Gets the mode (page) displayed */	public int getMode() {		if (infoBar!=null)			return infoBar.getMode();		else			return 0;	}		/*--------------------------------WINDOW SIZE, POSITION ----------------------------------*/	/*.................................................................................................................*/	/** OuterContainer is telling window its size was reset MAY BE DEFUNCT*/	public void containerSizeReset(){		if (setSizeDebugg>=0) {  //something else is setting container bounds; react by storing new content areas			Insets insets = getInsets();			if ((oldInsetTop<0 || oldInsetBottom <0 || oldInsetRight<0 || oldInsetLeft<0) && (0==insets.top || 0==insets.bottom || 0==insets.right || 0==insets.left) ) {			}			else if (oldInsetTop!=insets.top || oldInsetBottom !=insets.bottom || oldInsetRight!=insets.right || oldInsetLeft!=insets.left) {				setWindowSize(contentWidth, contentHeight);			}		}	}	/*.................................................................................................................*/	/** Widens the window. */	public void widenWindow(int widthIncrement) {		checkInsets();		setWindowSize(getFullWidth()+widthIncrement, getHeight());	}	/*.................................................................................................................*/	/** Heightens the window. */	public void heightenWindow(int heightIncrement) {		checkInsets();		setWindowSize(getFullWidth(), getHeight() + heightIncrement);	}	/*.................................................................................................................*/	public int getWindowWidth() {		return contentWidth;	}	/*.................................................................................................................*/	public int getWindowHeight() {		return contentHeight;	}	/*.................................................................................................................*/	/** Sets the window size.  To be used instead of setSize. */	public void setWindowSize(int width, int height) {		setSavedDimensions(width, height);		contentHeight = height;		contentWidth = width;		Insets insets = getInsets();		setSizeDebugg--;		int outerHeight = contentHeight+infoBarHeight + explanationHeight + annotationHeight+ insets.top +insets.bottom + graphics[0].getLedgePanelHeight();		outerContents.setBounds(insets.left,insets.top ,contentWidth + insets.left + insets.right, outerHeight);//		storeInsets(insets);		//outerContents.setBounds(0,insets.top ,contentWidth, contentHeight+infoBarHeight+ insets.top +insets.bottom);//		//outerContents is responsible for changing sizes of infoBar, contents, etc.		setSize(contentWidth+insets.left+insets.right, outerHeight);  //for some reason, insets.bottom doesn't seem needed+ insets.bottom		setSizeDebugg++;		validate();		saveFullDimensions();		windowResized();	}		public void pack(){		setSizeDebugg--;		super.pack();		setSizeDebugg++;	}	private void storeInsets(Insets insets){		oldInsetTop=insets.top;		oldInsetBottom=insets.bottom;		oldInsetRight= insets.right;		oldInsetLeft= insets.left; 	}	/*.................................................................................................................*/	private boolean checkInsets(){		Insets insets = getInsets();		if (oldInsetTop<0 || oldInsetBottom <0 || oldInsetRight<0 || oldInsetLeft<0) {			storeInsets(insets);			return true;		}		return true;	}	/*.................................................................................................................*/	/** Sets the size of the window (not to be used directly) */	public void setSize(int w, int h) {		if (setSizeDebugg>=0) {			MesquiteMessage.warnProgrammer("Programmer: use setWindowSize instead of setSize for MesquiteWindows: " + getTitle());		}		super.setSize(w,h);	}	/*.................................................................................................................*/	/** Sets the size of the window (not to be used directly) */	public void setBounds(int x, int y, int w, int h) {		if (checkInsets())			super.setBounds(x, y, w,h);	}	/*.................................................................................................................*/	/** Gets the minimum height of the content area of the window */	public int getMinimumContentHeight(){		return 200;	}	/*.................................................................................................................*/	/** Gets the minimum size of the window */	public Dimension getMinimumSize(){		//return new Dimension(100,100);		Insets insets = getInsets();		int width;		if (showInfoBar) 			width = insets.right+infoBar.getInfoBarWidth()+4;		else			width = insets.right+200;		return new Dimension(width, infoBarHeight + explanationHeight + annotationHeight+ insets.top +insets.bottom+getMinimumContentHeight());	}	/*.................................................................................................................*/	/** Gets the content width of the window (excluding the insets) */	public int getFullWidth(){		Insets insets = getInsets();		return (getBounds().width- insets.left - insets.right);	}	/*.................................................................................................................*/	/** Gets the content width of the graphics content area of the window (excluding the insets AND any palette) */	public int getWidth(){		Insets insets = getInsets();		if (graphics==null)			return 0;		if (graphics[0] == null || getBounds() == null)			return 0;		ToolPalette palette =graphics[0].getPalette();		int baseWidth = getBounds().width;		if (palette != null)			baseWidth -= palette.getWidth();		if (insets !=null)			baseWidth -= insets.left + insets.right;		baseWidth -= graphics[0].getSidePanelWidth();				return baseWidth;	}	/*.................................................................................................................*/	/** Gets the content height of the window (excluding the insets) */	public int getHeight(){		if (graphics[0] == null)			return 0;		Insets insets = getInsets();		if (getBounds()==null)			return 0;		if (insets==null)			return (getBounds().height - infoBarHeight - explanationHeight -annotationHeight) - graphics[0].getLedgePanelHeight();		return (getBounds().height - infoBarHeight -explanationHeight -annotationHeight- insets.top-insets.bottom - graphics[0].getLedgePanelHeight());	}	/*.................................................................................................................*/	/** Gets the content height of the window (excluding the insets) */	private int getFullHeight(){		Insets insets = getInsets();		if (getBounds()==null)			return 0;		if (insets==null)			return (getBounds().height - infoBarHeight - explanationHeight -annotationHeight);		return (getBounds().height - infoBarHeight -explanationHeight -annotationHeight- insets.top-insets.bottom);	}	/*.................................................................................................................*/	/** Center the passed window in the screen */	public static void centerWindow(Window f){		centerWindow(f, true, true);	}	/*.................................................................................................................*/	/** Center the passed window in the screen */	public static void centerWindow(Window f, boolean horizontally, boolean vertically){		Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();		int v, h;		if (horizontally)			h = (screenSize.width-f.getBounds().width)/2;		else			h = f.getBounds().x;		int menuBarHeight = 0;		if (!StringUtil.blank(System.getProperty("mrj.version")))			menuBarHeight = 32;		if (vertically) {			v = (screenSize.height-f.getBounds().height - menuBarHeight)/2 + menuBarHeight;			if (v < menuBarHeight)				v = menuBarHeight;		}		else			v = f.getBounds().y;					f.setLocation(h, v);	}	/*.................................................................................................................*/	/** Center the passed window in the screen */	public static void centerWindowTile(Window f, int tile){		Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();		if (tile==0) 			f.setLocation((screenSize.width-f.getBounds().width)/2, (screenSize.height-f.getBounds().height)/2-48);		else if (tile==1) 			f.setLocation((screenSize.width-f.getBounds().width)/2, (screenSize.height-f.getBounds().height)/2-48+f.getBounds().height+18);		else {			int tileVerAmount = (tile % 5)*(f.getBounds().height/2);			int tileHorAmount = (tile / 5)*(f.getBounds().width/2);			f.setLocation((screenSize.width-f.getBounds().width)/2+tileHorAmount, (screenSize.height-f.getBounds().height)/2-48+tileVerAmount+f.getBounds().height+10);		}	}		/*--------------------------------WINDOW order ----------------------------------*/	/*.................................................................................................................*/	/** INCOMPLETE. 	public void toBack(){		super.toBack();		MesquiteMessage.warnProgrammer("Progammer: window.toBack() should be avoided until window ranks system works properly");	}		/*.................................................................................................................*/	/** INCOMPLETE. */	public void toFront(){		super.toFront();		if (isVisible() && rank!=highestRank) { //window of intermediate rank brought to front; must readjust ranks of all			rank = ++highestRank;		}	}	/*.................................................................................................................*/	/** INCOMPLETE. */	public int getRank(){		return rank;	}	/*.................................................................................................................*/	boolean doingShow = false;	int savedX = 0;	int savedY = 0;	int savedW = 0;	int savedH = 0;	int savedFullW = 0;	int savedFullH = 0;	protected void setSavedDimensions(int w, int h){		savedW = w;		savedH = h;	}	protected void saveFullDimensions(){		savedFullW = getBounds().width;		savedFullH = getBounds().height;	}		/** Shows the window */	public void setVisible(boolean vis) {		boolean wasVis = isVisible();		if (vis){			if (!GUIavailable || suppressAllWindows)				return;			doingShow = true;			savedX = getLocation().x;			savedY = getLocation().y;			savedW = contentWidth;			savedH = contentHeight;			windowShowTime.start();		}		super.setVisible(vis);				/*if (rank ==-1)			rank = ++highestRank;		else if (rank==lowestRank) { //need lowestRank if toBack is to be used			lowestRank++;			rank = ++highestRank;		}		else */		if (vis){			if (rank!=highestRank) { //window of intermediate rank brought to front; must readjust ranks of all				rank = ++highestRank;			}						doingShow = false;			windowShowTime.end();		}		if (!wasVis && vis && graphics[0]!=null)			graphics[0].requestFocus();	}	/*--------------------------------MENU BARS ----------------------------------*/	private final void deassign(MenuItem mi){		if (mi ==null)			return;		if (mi instanceof MesquiteMenuItem)			((MesquiteMenuItem)mi).disconnect();		else if (mi instanceof MesquiteCheckMenuItem)			((MesquiteCheckMenuItem)mi).disconnect();		else if (mi instanceof MesquiteSubmenu) {			((MesquiteSubmenu)mi).disconnect();			for (int k=0; k<((MesquiteSubmenu)mi).getItemCount(); k++) {				deassign( ((MesquiteSubmenu)mi).getItem(k));			}		}	}	public final void deassignMenus(){	 	if (menuBar!=null) {	 		try {	 			for (int i=0; i<menuBar.getMenuCount(); i++){  	 			Menu m = menuBar.getMenu(i);	 			for (int j = 0; j< m.getItemCount(); j++) {	 				deassign(m.getItem(j));	 			}	 		}	 		menuBar.disconnect();	 		}	 		catch (Exception e){	 		}	 	}	}	/*.................................................................................................................*/	/** DEBUGGING */	public static void setReportMenuResets(boolean r){		reportMenuResets = r;	}	/*.................................................................................................................*/	/** Resets the menu bar of the window */	public void resetMenus(){				resetMenuTime.start();		deassignMenus();		MesquiteMenuBar tempMenuBar = new MesquiteMenuBar(this); //could delete??		resetMenuTime.end();		if (ownerModule==null) {			MesquiteMessage.printStackTrace("@@@@@@@@@@@@@@@@@@null ownerModule in window");			return;		}		else {				ownerModule.composeMenuBar(tempMenuBar, this); //could set to menuBar		}		resetMenuTime.start();		setMenuBar(tempMenuBar);  //IF THIS IS THE FIRST TIME, and size is not set afterward, should reset size		menuBar = tempMenuBar;//need to remember this in case anyone wants access to menu bar				menuResets++;		if (reportMenuResets)			System.out.println(Integer.toString(menuResets) + " menu resets for " + getTitle());		resetMenuTime.end();	}	public MesquiteMenuBar getMesquiteMenuBar(){		return menuBar;	}	public void setMinimalMenus(boolean minimal){		minimalMenus = minimal;	}	public boolean getMinimalMenus(){		return minimalMenus;	} 	 /** If a window has a special copy paste mechanism, it should return commands in these methods*/    	 public MesquiteCommand getUndoCommand() {		return null;    	 }    	 public MesquiteCommand getCopySpecialCommand() {		return null;    	 }    	 public String getCopySpecialName() {		return "Copy Special";    	 }    	 public MesquiteCommand getPasteSpecialCommand() {		return null;    	 }    	 public String getPasteSpecialName() {		return "Paste Special";    	 }     	 public MesquiteCommand getCutCommand() {		return null;   	 }   	 public MesquiteCommand getPasteCommand() {		return null;    	 }   	 public MesquiteCommand getClearCommand() {		return null;    	 }    	 public void selectAll() {		if (annotationHasFocus()){			annotationArea.textArea.selectAll();		}		else if (infoBar.getMode()==InfoBar.GRAPHICS) {			selectAllGraphicsPanel();		}		else {			TextArea textArea = infoBar.getTextArea(infoBar.getMode());			if (textArea!=null){				textArea.selectAll();			}		}  	 }  	   	public void selectAllGraphicsPanel(){  	}  		public void copy(){		if (annotationHasFocus()){			String s = annotationArea.textArea.getSelectedText();			Clipboard clip = Toolkit.getDefaultToolkit().getSystemClipboard();			StringSelection ss = new StringSelection(s);			clip.setContents(ss, ss);		}		else if (infoBar.getMode()==InfoBar.GRAPHICS) {			copyGraphicsPanel();		}		else {			infoBar.refreshText(infoBar.getMode());			TextArea textArea = infoBar.getTextArea(infoBar.getMode());			if (textArea!=null){				String s = textArea.getSelectedText();				if (StringUtil.blank(s))					s = textArea.getText();				Clipboard clip = Toolkit.getDefaultToolkit().getSystemClipboard();				StringSelection ss = new StringSelection(s);				clip.setContents(ss, ss);			}		}			 }	public void copyGraphicsPanel(){		infoBar.refreshText(InfoBar.TEXT_CONTENTS);		TextArea textArea = infoBar.getTextArea(InfoBar.TEXT_CONTENTS);		if (textArea!=null){			String s = textArea.getSelectedText();			if (StringUtil.blank(s))				s = textArea.getText();			if (StringUtil.blank(s))				return;			Clipboard clip = Toolkit.getDefaultToolkit().getSystemClipboard();			StringSelection ss = new StringSelection(s);			clip.setContents(ss, ss);		}	 }	 	/*-------------------------------- COMMANDS  ----------------------------------*/	/*.................................................................................................................*/	/** Incorporate into the passed snapshot the complete snapshot commands for the window (including getWindow, tell It, and endTell)*/	public void incorporateSnapshot(Snapshot snap, MesquiteFile file){  	 	Snapshot fromWindow =getSnapshot(file);		snap.addLine("getWindow");		snap.addLine("tell It");		snap.incorporate(fromWindow, true);		snap.addLine("endTell");	}	/*.................................................................................................................*/	/** Gets basic snapshot for window, including size, location. */  	 public Snapshot getSnapshot(MesquiteFile file) {    	 	Snapshot temp = new Snapshot();  	 	temp.addLine("setSize " + getFullWidth() + " " + getFullHeight());   	 	temp.addLine("setLocation " + getBounds().x + " " + getBounds().y);   	 	temp.addLine("setFont " + ParseUtil.tokenize(currentFont.getName())); //fixed to tokenize 12 Oct 01   	 	temp.addLine("setFontSize " + currentFont.getSize());   	 	if (showInfoBar)   	 		temp.addLine("onInfoBar");   	 	else   	 		temp.addLine("offInfoBar");    	 	temp.addLine("setExplanationSize " + explanationHeight);    	 	temp.addLine("setAnnotationSize " + annotationHeight);   	 	temp.addLine("setFontIncAnnot " + StringUtil.tokenize(Integer.toString(annotationArea.fontIncrement)));   	 	temp.addLine("setFontIncExp " + StringUtil.tokenize(Integer.toString(explanationArea.fontIncrement)));    	 	/*if (!StringUtil.blank(windowAnnotation.toString())) {    	 		temp.addLine("setAnnotation " + ParseUtil.tokenize(windowAnnotation.toString()));  	 	}  	 	*/  	 	if (graphics[0] != null && graphics[0].getPalette()!=null) {   	 		temp.addLine("getToolPalette");   	 		temp.addLine("tell It");   	 		temp.incorporate(graphics[0].getPalette().getSnapshot(file), true);   	 		temp.addLine("endTell");   	 	}   	 	if (getMode()>0)   	 		temp.addLine("showPage " + getMode()); 		if (ownerModule != null && ownerModule.getProject()!=null && ownerModule.getProject().activeWindowOfProject == this)   	 		temp.addLine("setActive"); //so that file save will remember foremost window 	 	return temp;  	 }  	 MesquiteInteger pos = new MesquiteInteger(0);	/*.................................................................................................................*/	public boolean setWindowFontSize(int fontSize) { 		if (!MesquiteInteger.isCombinable(fontSize)) 			fontSize = MesquiteInteger.queryInteger(MesquiteWindow.frameOfComponent(this), "Font size", "Font size for window", currentFont.getSize(), 4, 256); 		if (!MesquiteInteger.isCombinable(fontSize)) 			return false; 		Font fontToSet = new Font (currentFont.getName(), currentFont.getStyle(), fontSize); 		setWindowFont(fontToSet); 		return true;    	 }	/*.................................................................................................................*/	public void setWindowFont(String fontName) { 		Font fontToSet = new Font (fontName, currentFont.getStyle(), currentFont.getSize()); 		setWindowFont(fontToSet);    	 }    	     	 Font getCurrentFont(){    	 	return currentFont;    	 }	/*.................................................................................................................*/	public void setWindowFont(Font fontToSet) { 		if (fontToSet!= null) { 			currentFont = fontToSet; 			//setFont(fontToSet); 			graphics[0].setFont(currentFont); 			if (annotationArea!=null) 				annotationArea.setFont(currentFont); 			if (explanationArea!=null) 				explanationArea.setFont(currentFont); 			repaintAll(); 		}    	 }	/*.................................................................................................................*/	/** Respond to commands sent to the window. */    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(MesquiteWindow.class, "Makes the window visible", null, commandName, "showWindow")) {    	 		//if (!isVisible())     	 		//	setVisible(true);     	 		setVisible(true);   	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Forces repaint of window", null, commandName, "forceRepaint")) {     	 		repaintAll();   	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Sets this window to be foremost; to be used in scripting", null, commandName, "setActive")) {     	 		if (ownerModule != null && ownerModule.getProject()!=null)     	 			ownerModule.getProject().windowToActivate = this; //so that file read will restore foremost window   	 	}    		 else if (checker.compare(MesquiteWindow.class, "Closes the window (calls owner module's windowGoAway)", null, commandName, "closeWindow")) {			closeWindow();   	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Composes and shows the menu and control explanations web page", null, commandName, "showExplanations")) {			CommandChecker.showExplanations(graphics[0], getMenuBar(), getName());     	 	}    	 	else if (checker.compare(this.getClass(), "Shows the commands needed to put window and its modules into their current states", null, commandName, "showSnapshot")) {			if (getOwnerModule() == null)				return null;			FileCoordinator mb = getOwnerModule().getFileCoordinator();			if (mb!=null) {				String s = "Snapshot: commands needed to put window and its modules into their current states\n" + Snapshot.getSnapshotCommands(getOwnerModule(), null, "");				return mb.displayText(s, "Snapshot of commands", commandRec);			}			else {				MesquiteModule.mesquiteTrunk.alert("Snapshot not available (no module associated with window)");			}    	 	}				else if (checker.compare(this.getClass(), "Put text version of window into log", null, commandName, "text")) {			if (ownerModule !=null)				ownerModule.logln("Window " + getName() + "\n" + getTextContents());					}		else if (checker.compare(MesquiteWindow.class, "Copies current selection to clipboard", null, commandName, "copy")) {			copy();		}		else if  (checker.compare(MesquiteWindow.class, "Copies current selection to clipboard and clears from selection", null, commandName, "cut")) {			if (!annotationHasFocus()){				MesquiteCommand com = getCutCommand();				if (com!=null)					com.doItMainThread("", null, this);  // command invoked			}			else {				TextArea ta = annotationArea.textArea;				String s = ta.getSelectedText();				Clipboard clip = Toolkit.getDefaultToolkit().getSystemClipboard();				StringSelection ss = new StringSelection(s);				clip.setContents(ss, ss);				ta.replaceRange("", ta.getSelectionStart(), ta.getSelectionEnd());				setAnnotation(ta.getText(), null);			}		}		else if  (checker.compare(MesquiteWindow.class, "Clears current selection", null, commandName, "clear")) {			if (!annotationHasFocus()){				MesquiteCommand com = getClearCommand();				if (com!=null)					com.doItMainThread("", null, this);  // command invoked			}			else {				TextArea ta = annotationArea.textArea;				ta.replaceRange("", ta.getSelectionStart(), ta.getSelectionEnd());				setAnnotation(ta.getText(), null);			}		}				else if  (checker.compare(MesquiteWindow.class, "Pastes from clipboard into current selection", null, commandName, "paste")) {			if (!annotationHasFocus()){				MesquiteCommand com = getPasteCommand();				if (com!=null)					com.doItMainThread("", null, this);  // command invoked			}			else {				Clipboard clip = Toolkit.getDefaultToolkit().getSystemClipboard();				Transferable t = clip.getContents(this);				try {					String s = (String)t.getTransferData(DataFlavor.stringFlavor);					if (s!=null) {						TextArea ta = annotationArea.textArea;						int st = ta.getSelectionStart();	 					ta.replaceRange(s, ta.getSelectionStart(), ta.getSelectionEnd());						Annotatable a = annotationArea.getAnnotatable();						if (a == null)							setAnnotation(ta.getText(), null);						else							a.setAnnotation(ta.getText(), true);						ta.setSelectionStart(st + s.length());						ta.setSelectionEnd(st + s.length());					}				}				catch(Exception e){					MesquiteMessage.printStackTrace(e);				}			}		}		else if  (checker.compare(MesquiteWindow.class, "Selects all", null, commandName, "selectAll")) {			selectAll();		}		    	 	else if (checker.compare(MesquiteWindow.class, "Presents dialog through which user can send commands to the module in charge of the window", null, commandName, "sendScript")) {			MesquiteModule module = getOwnerModule();    	 		if (module!=null) {				Puppeteer p = new Puppeteer(module);				p.dialogScript(module, module.containerOfModule(), "owner module (" + module.getName() + ") of this window");    	 		}    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Sets which page of the window (graphics, text, explanations, parameters, employee tree, etc.) is showing", "[page number]", commandName, "showPage")) {			if (infoBar==null)				return null;			MesquiteInteger pos = new MesquiteInteger(0);			int mode = MesquiteInteger.fromString(arguments, pos);			if (MesquiteInteger.isCombinable(mode)){				infoBar.setMode(mode);			}    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Prints the contents of the window", null, commandName, "printWindow")) {    	 		prWindow(MesquitePrintJob.NATURAL);    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Prints the contents of the window to fit a page", null, commandName, "printToFit")) {    	 		prWindow(MesquitePrintJob.AUTOFIT);    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Sends the contents of the window to a PDF file",null,commandName,"printToPDF")) {    	 		pdfWindow(MesquitePrintJob.AUTOFIT);    	 	}   	 	else if (checker.compare(MesquiteWindow.class, "Opens the print window (for cases where the printing calls are separated)", null, commandName, "openPrintWindowToFit")) {			MainThread.setShowWaitWindow(false);    	 		openPrWindow(MesquitePrintJob.AUTOFIT);			MainThread.setShowWaitWindow(true);    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Opens the print window (for cases where the printing calls are separated)", null, commandName, "openPrintWindow")) {			MainThread.setShowWaitWindow(false);    	 		openPrWindow(MesquitePrintJob.NATURAL);			MainThread.setShowWaitWindow(true);    	 	}    	 	else if (checker.compare(MesquiteWindow.class,  "Prints the window (for cases where the printing calls are separated)", null, commandName, "doPrintWindow")) {			MainThread.setShowWaitWindow(false);    	 		doPrWindow();			MainThread.setShowWaitWindow(true);    	 	}    	 	else if (checker.compare(MesquiteWindow.class,  "Closes the print window (for cases where the printing calls are separated)", null, commandName, "closePrintWindow")) {			MainThread.setShowWaitWindow(false);    	 		closePrWindow();			MainThread.setShowWaitWindow(true);    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Returns the tool palette of the window", null, commandName, "getToolPalette")) {     	 		return graphics[0].getPalette();     	 	}   	 	else if (checker.compare(MesquiteWindow.class, "Clones the window if possible", null, commandName, "cloneWindow")) {    	 		String cloneCommand = ownerModule.getEmployer().getClonableEmployeeCommand(ownerModule);    	 		if (!StringUtil.blank(cloneCommand)){    	 			cloneCommand += "\ntell It;\n";				cloneCommand += Snapshot.getSnapshotCommands(ownerModule, null, "");				cloneCommand += "\nendTell;";				Puppeteer p = new Puppeteer(ownerModule.getEmployer());				MesquiteInteger pos = new MesquiteInteger(0);				CommandRecord previous = MesquiteThread.getCurrentCommandRecord();				CommandRecord record = new CommandRecord(true);				MesquiteThread.setCurrentCommandRecord(record);				Object obj = p.sendCommands(ownerModule.getEmployer(), cloneCommand, pos, "", false, null, record, CommandChecker.defaultChecker);				if (obj != null){					MesquiteWindow w = null;					if (obj instanceof MesquiteWindow)						w = (MesquiteWindow)obj;					else if (obj instanceof MesquiteModule)						w = ((MesquiteModule)obj).getModuleWindow();					if (w!=null)						w.doCommand("setLocation", Integer.toString(w.getLocation().x + 20) + " " + (w.getLocation().y + 20), record, CommandChecker.defaultChecker);				}								MesquiteThread.setCurrentCommandRecord(previous);    	 		}    	 	}   	 	else if (checker.compare(MesquiteWindow.class, "Saves a macro that serves as a macro to reproduce an analysis or window", null, commandName, "saveMacroForWindow")) {	 		saveWindowMacro(0);    	 	}   	 	else if (checker.compare(MesquiteWindow.class, "Saves a macro that serves as a macro to reproduce an analysis or window", null, commandName, "saveMacroForAnalysis")) {	 		saveWindowMacro(MesquiteMacro.ANALYSIS);    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Saves the text version of the window to a file", "[file name]", commandName, "saveTextToFile")) {    	 		if (StringUtil.blank(arguments)) {    	 			arguments = MesquiteFile.saveFileAsDialog("Save window text");	    	 		if (StringUtil.blank(arguments))	    	 			return null;	    	 		return saveTextToFile(arguments, false);    	 		}			 else     	 			return saveTextToFile(MesquiteFile.composePath(ownerModule.getProject().getHomeDirectoryName(),ParseUtil.getFirstToken(arguments, pos)), false);    	 		    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Appends the text version of the window to an existing file", "[file name]", commandName, "appendTextToFile")) {     	 		if (StringUtil.blank(arguments)) {    	 			arguments = MesquiteFile.saveFileAsDialog("Append window text");	   	 		if (StringUtil.blank(arguments))	    	 			return null;	     	 		return saveTextToFile(arguments, true);   	 		}    	 		else    	 			return saveTextToFile(MesquiteFile.composePath(ownerModule.getProject().getHomeDirectoryName(),ParseUtil.getFirstToken(arguments, pos)), true);    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Toggles whether the information bar at the top of the window is shown or not", null, commandName, "toggleInfoBar")) {     	 		setShowInfoBar(!showInfoBar); //todo why are this and the following two not replaced by a single setInfoBar [on or off]???    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Shows the information bar at the top of the window", null, commandName, "onInfoBar")) {     	 		if (!showInfoBar)    	 			setShowInfoBar(true);    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Hides the information bar at the top of the window", null, commandName, "offInfoBar")) {     	 		if (showInfoBar)    	 			setShowInfoBar(false);    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Executes the macro file", "[file name]", commandName, "doMacro")) {     	 		if (ownerModule!=null) {				Puppeteer p = new Puppeteer(ownerModule);				p.applyMacroFile(ParseUtil.getFirstToken(arguments, pos), ownerModule, commandRec);    	 		}    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Returns the module owning the window", null, commandName, "getOwnerModule")) {     	 		return ownerModule;    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Sets the size of the window", "[width in pixels][height in pixels]", commandName, "setSize")) {   	 		MesquiteInteger io = new MesquiteInteger(0);   			int width= MesquiteInteger.fromString(arguments, io);   			int height= MesquiteInteger.fromString(arguments, io);    	 		if (MesquiteInteger.isCombinable(width) && MesquiteInteger.isCombinable(height)) {    	 			setWindowSize(width, height);    	 		}    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Sets the height of the explanation area", "[height in pixels]", commandName, "setExplanationSize")) {   	 		MesquiteInteger io = new MesquiteInteger(0);   			int height= MesquiteInteger.fromString(arguments, io);    	 		if (MesquiteInteger.isCombinable(height) && height>=0) {    	 			setShowExplanation(height !=0,  height);    	 		}    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Sets the height of the annotation area", "[height in pixels]", commandName, "setAnnotationSize")) {   	 		MesquiteInteger io = new MesquiteInteger(0);   			int height= MesquiteInteger.fromString(arguments, io);    	 		if (MesquiteInteger.isCombinable(height) && height>=0) {    	 			setShowAnnotation(height !=0,  height);    	 		}    	 	}    	 	/*    	 	else if (checker.compare(MesquiteWindow.class, "Sets the annotation for the window.", "[annotation]", commandName, "setAnnotation")) {   	 		if (useAnnotatableForAnnotation)   	 			return null;   	 		MesquiteInteger io = new MesquiteInteger(0);   	 		String note = ParseUtil.getToken(arguments, io);   	 		if (!StringUtil.blank(note)) {   	 			windowAnnotation.setValue(note);   	 			if (windowAnnotation == defaultAnnotation)   	 				setAnnotation(windowAnnotation, false, null);   	 		   	 		}    	 	}    	 	*/    	 	else if (checker.compare(MesquiteWindow.class, "Sets the location of the window", "[x coordinate of upper left][y coordinate of upper left]", commandName, "setLocation")) {   	 		MesquiteInteger io = new MesquiteInteger(0);   			int x= MesquiteInteger.fromString(arguments, io);   			int y= MesquiteInteger.fromString(arguments, io);    	 		if (MesquiteInteger.isCombinable(x) && MesquiteInteger.isCombinable(y)) {				Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();				if (x> screenSize.width-16)					x=screenSize.width-64;				else if (x+getBounds().width<16)					x= 16 - getBounds().width;				if (y> screenSize.height-16)					y=screenSize.height-64;				else if (y+getBounds().height<16)					y= 16 - getBounds().height;				if (y<0)					y=0;				if (MesquiteTrunk.isMacOSX() && y<22 && x<0)  //workaround for bug in OS X; June 2004					x=0;    	 			setLocation(x, y);    	 		}    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Sets the font of the window", "[name of font]", commandName, "setFont")) {    	 		String fontName = ParseUtil.getFirstToken(arguments, pos);    	 		setWindowFont(fontName);    	 	}    	 	else if (checker.compare(MesquiteWindow.class, "Sets the font size of the window", "[font size]", commandName, "setFontSize")) {    	 		int fontSize = MesquiteInteger.fromString(arguments);    	 		if (!setWindowFontSize(fontSize))    	 			return null;    	 	}     	 	else if (checker.compare(MesquiteWindow.class, "Sets the font size difference of the explanation area", "[font increment]", commandName, "setFontIncExp")) {    	 		int fontInc = MesquiteInteger.fromFirstToken(arguments, pos);    	 		if (MesquiteInteger.isCombinable(fontInc) && fontInc< 100 && fontInc > -100) {    	 			explanationArea.fontIncrement= fontInc;    	 			explanationArea.resetFont();    	 		}    	 			return null;    	 	}     	 	else if (checker.compare(MesquiteWindow.class, "Sets the font size difference of the annotations area", "[font increment]", commandName, "setFontIncAnnot")) {    	 		int fontInc = MesquiteInteger.fromFirstToken(arguments, pos);    	 		if (MesquiteInteger.isCombinable(fontInc) && fontInc< 100 && fontInc > -100) {    	 			annotationArea.fontIncrement= fontInc;    	 			annotationArea.resetFont();    	 		}    	 		return null;    	 	}   	 	else if (checker.compare(MesquiteWindow.class, "Dumps to the log a list of the employees of the owner module", null, commandName, "listEmployees")) {    	 		if (ownerModule!=null)    	 			ownerModule.logln(ownerModule.listEmployees(""));    	 	}    	 	else {			//AFTERDEMO:    	 		if (commandName!=null && !checker.getAccumulateMode()) {				 MesquiteMessage.warnProgrammer("Window " + getName() + " did not respond to command " + commandName + " with arguments (" + arguments + ")");    	 		}    	 	}		return null;   	 }   	    	 private void saveWindowMacro(int preferredMenu){ 		MesquiteModule mb = ownerModule.getEmployer(); 		if (mb == null) 			return;		String cloneCommand = mb.getClonableEmployeeCommand(ownerModule);		String beforeTell = "";		String afterTell = "endTell;\n";		while (mb !=null && mb.getModuleWindow()==null) {			beforeTell = "getEmployee " + "#" + mb.getClass().getName()  + ";\ntell It;\n" + beforeTell;			afterTell += "endTell;\n";							mb = mb.getEmployer();		}		MesquiteModuleInfo mmi = mb.getModuleInfo(); 		if (mmi == null) 			return;	 		if (StringUtil.blank(cloneCommand)) 			beforeTell += "getEmployee " + "#" + ownerModule.getClass().getName() + ";\ntell It;\n"; 		else 			beforeTell += cloneCommand + "\ntell It;\n"; 		String recipe =  beforeTell;		recipe += Snapshot.getSnapshotCommands(ownerModule, null, "");		recipe +=  afterTell;   	 	MesquiteMacro.saveMacro(mb, "Untitled Macro for Window", preferredMenu, recipe);   	 }	/*.................................................................................................................*/	public String getName(){		return getTitle();	}		/*.................................................................................................................*/	/** When called the window will determine its own title.  MesquiteWindows need	to be self-titling so that when things change (names of files, tree blocks, etc.)	they can reset their titles properly*/	public abstract void resetTitle();	/*.................................................................................................................*/	public static void resetAllTitles(){ 		Enumeration e = MesquiteTrunk.windowVector.elements(); 		while (e.hasMoreElements()) {			Object obj = e.nextElement();			MesquiteWindow mw = (MesquiteWindow)obj;			mw.resetTitle(); 		}	}		/** to be called to add to log*/	public final void logln(String s) {		if (logText == null)			logText = new StringBuffer("Log for window" + getTitle() +  "\n");		logText.append(s + "\n");	}	/*.................................................................................................................*/	/** to be called to add to log*/	public final void log(String s) {		if (logText == null)			logText = new StringBuffer("Log for window" + getTitle() +  "\n");		logText.append(s);	}	/*.................................................................................................................*/	/** to be called to add to log*/	public final String getLogText() {		if (logText == null)			logText = new StringBuffer("Log for window" + getTitle() +  "\n");		return logText.toString();	}	/*.................................................................................................................*/	public void hide(){		super.hide();		if (!suppressAllWindows && autoShow && mwwe!=null && noWindowsShowing() &&  !MesquiteTrunk.mesquiteTrunk.isDoomed()) {			MesquiteModule.mesquiteTrunk.doCommand("showAbout","", new CommandRecord(false), CommandChecker.defaultChecker);			if (!AlertDialog.query(MesquiteModule.mesquiteTrunk.containerOfModule(), "How to Quit", "If you hadn't intended to quit Mesquite, select \"Go back to Mesquite\"..  Because Mesquite needs at least one window open, the Mesquite window will be shown.  If you want to Force Quit right now, select \"Force Quit\" now (the standard and safer way to quit Mesquite is to select Quit Mesquite from the File menu).", "Go back to Mesquite", "Force Quit"))				MesquiteModule.mesquiteTrunk.doCommand("goAwayForceQuit",null, new CommandRecord(false), CommandChecker.defaultChecker);		}	}		public boolean disposed() {		return wasDisposed;	}	public void waitUntilDisposable() {		/*int pp = 0;		while (painting>0) {			try {				Thread.sleep(50);			}			catch (InterruptedException e) {				return;			}			if (++pp % 5 == 0){ //TODO: should be 1000 ??				MesquiteMessage.warnProgrammer("Waiting (" + pp + ") to dispose window " + getName() + " " +painting);			}			if (pp > 15)				return;		}		*/		if (painting>0) {			try {				Thread.sleep(50); //pause to allow some time to clean up			}			catch (InterruptedException e) {				return;			}		}	}	private void disposeAll(Component c){		if (c==null)			return;		if (c instanceof MousePanel)			((MousePanel)c).dispose();		if (c instanceof Container){			Component[] cc = ((Container)c).getComponents();			if (cc!=null && cc.length>0)				for (int i=0; i<cc.length; i++)					disposeAll(cc[i]);		}			}	/*.................................................................................................................*/	public void dispose() {		disposing = true;		if (activeWindow == this)			activeWindow = null; 		if (ownerModule != null && ownerModule.getProject()!=null && ownerModule.getProject().activeWindowOfProject == this) 			ownerModule.getProject().activeWindowOfProject = null;		hide();		waitUntilDisposable();		disposeAll(graphics[0]);		disposeAll(palette);		disposeAll(explanationArea);		disposeAll(annotationArea);		removeKeyListener(graphics[0], currentTool); 		if (annotationArea!=null)			annotationArea.dispose();		if (explanationArea!=null)			explanationArea.dispose();		annotationArea.setExplanation((Annotatable)null); 		if (infoBar!=null)			infoBar.dispose();		if (ownerModule!=null)			ownerModule.setModuleWindow(null);		MesquiteModule.mesquiteTrunk.windowVector.removeElement(this, false);		deassignMenus();		ETContentArea etc = (ETContentArea)graphics[1];		outerContents.dispose();		if (infoBar!=null)			infoBar.dispose();		remove(outerContents);		if (etc!=null)			etc.dispose();	 	menuBar=null;		wasDisposed = true;		ownerModule = null;				if (infoBarMenuItem !=null) {			infoBarMenuItem.disconnectable = true;			infoBarMenuItem.disconnect();		}		if (showCommand!=null){			showCommand.dispose();			showInfoBarCommand.dispose();			saveAsTextCommand.dispose();			printCommand.dispose();			printToFitCommand.dispose();			printToPDFCommand.dispose();			setFontCommand.dispose();			setFontSizeCommand.dispose();			listEmployeesCommand.dispose();			doMacroCommand.dispose();			showExplanationsCommand.dispose();			showSnapshotCommand.dispose();			sendScriptCommand.dispose();			showFileCommand.dispose();			closeWindowCommand.dispose();		}		showCommand=null;		showInfoBarCommand=null;		saveAsTextCommand.dispose();		printCommand=null;		printToFitCommand = null;		printToPDFCommand = null;		setFontCommand=null;		setFontSizeCommand =null;		listEmployeesCommand =null;		doMacroCommand = null;		showExplanationsCommand = null;		showSnapshotCommand = null;		sendScriptCommand = null;		showFileCommand = null;		closeWindowCommand = null;				infoBarMenuItem =null;				boolean done = false;		while (!done){  //dangerous? but addressed bugs in OS X!			try {				super.dispose();				done = true;			}			catch (Exception e){				MesquiteMessage.warnProgrammer("Exception in disposing window " + e);				PrintWriter pw = MesquiteFile.getLogWriter();				if (pw!=null)					e.printStackTrace(pw);				done = true;			}		}			}	/*.................................................................................................................*/	/** windows with manually resized components (i.e. null layoutmanagers) can override to respond to window resizing here */	public void windowResized(){	}	/*.................................................................................................................*/	public void buttonHit(String label, Button button){		//buttons can use this to say to the window they've been hit	}	/*.................................................................................................................*/	protected void closeWindow(){			if (ownerModule!=null) {				if (getOwnerModule().isDoomed() || disposing)					return;				if (autoShow && noWindowsShowing(this, ownerModule.getProject())) {					FileCoordinator p = ownerModule.getFileCoordinator();					if (p!=null)  {						int response=2;						response = AlertDialog.query(MesquiteModule.mesquiteTrunk.containerOfModule(), "Close Project?", "You have just requested to close the last open window of a project.  If you want to close the project, select \"Close Project\".  Otherwise, select \"Continue\", which will bring up a small window to represent the project.", "Continue", "Close Project", "Cancel", 3);						if (response==1){  //hit close project;							p.closeFile(p.getProject().getHomeFile(), new CommandRecord(false));							return;						} else if (response==2) //cancel							return;					}					ownerModule.windowGoAway(this);					if (p!=null) {						p.doCommand("showWindow","", new CommandRecord(false), CommandChecker.defaultChecker);					}					else						MesquiteMessage.warnProgrammer("file coord null");				}				else 					ownerModule.windowGoAway(this);			}			else {				hide();				dispose();			}			if (!suppressAllWindows && autoShow && noWindowsShowing()) {				MesquiteModule.mesquiteTrunk.doCommand("showAbout","", new CommandRecord(false), CommandChecker.defaultChecker);				if (!AlertDialog.query(MesquiteModule.mesquiteTrunk.containerOfModule(), "How to Quit", "If you hadn't intended to quit Mesquite, select \"Go back to Mesquite\"..  Because Mesquite needs at least one window open, the Mesquite window will be shown.  If you want to Force Quit right now, select \"Force Quit\" now (the standard and safer way to quit Mesquite is to select Quit Mesquite from the File menu).", "Go back to Mesquite", "Force Quit"))					MesquiteModule.mesquiteTrunk.doCommand("goAwayForceQuit",null, new CommandRecord(false), CommandChecker.defaultChecker);			}	}	boolean noWindowsShowing(MesquiteWindow w, MesquiteProject proj){		if (proj==null)			return noWindowsShowing();		if (MesquiteModule.mesquiteTrunk.windowVector.size() == 0)			return true;		else {			Enumeration e = MesquiteModule.mesquiteTrunk.windowVector.elements();	 		while (e.hasMoreElements()) {				MesquiteWindow win = (MesquiteWindow)e.nextElement();				if (win != w && !win.minimalMenus && win.isVisible() && win.ownerModule!=null && win.ownerModule.getProject()==proj)					return false;	 		}	 		return true;		}	}	boolean noWindowsShowing(){		if (MesquiteModule.mesquiteTrunk.windowVector.size() == 0)			return true;		else {			Enumeration e = MesquiteModule.mesquiteTrunk.windowVector.elements();	 		while (e.hasMoreElements()) {				MesquiteWindow win = (MesquiteWindow)e.nextElement();				if (!win.minimalMenus && win.isVisible())					return false;	 		}	 		return true;		}	}	/*.................................................................................................................*/	class MWCE extends ComponentAdapter{		MesquiteWindow w;		public MWCE (MesquiteWindow w){			super();			this.w = w;		}		public void componentResized(ComponentEvent e){			if (e==null || e.getComponent()!= w || (getOwnerModule()!=null && (getOwnerModule().isDoomed() || disposing)))				return;					if (savedFullH== getBounds().height&& savedFullW == getBounds().width) {			}			else if (doingShow || !isResizable()){				setWindowSize(savedW, savedH);			}			else {				setSizeDebugg--;				contentWidth = getWidth();				if (palette!=null)					contentWidth += palette.getWidth();				contentHeight = getHeight();				storeInsets(getInsets());				windowResized();				setSizeDebugg++;			}		}		public void componentMoved(ComponentEvent e){			if (doingShow)				setLocation(savedX,savedY);		}		public void componentShown(ComponentEvent e){			if (MesquiteTrunk.isMacOSXJaguar()) {				w.repaintAll();			}			Toolkit.getDefaultToolkit().sync();		}	}		/*.................................................................................................................*/	class MWWE extends WindowAdapter{		MesquiteWindow w;		public MWWE (MesquiteWindow w){			this.w = w;		}		public void windowClosing(WindowEvent e){			MesquiteModule.incrementMenuResetSuppression();			try {				if (MesquiteTrunk.isMacOS() && w!=activeWindow && activeWindow!=null) //workaround the Mac OS menu disappearance bug after closing a window					toFront();							if (w != null && w.closeWindowCommand != null)					w.closeWindowCommand.doIt(null); //this might be best done on separate thread, but because of menu disappearance bug after closing a window in Mac OS, is done immediately			}			catch (Exception ee){			}			MesquiteModule.decrementMenuResetSuppression();						//w.closeWindowCommand.doItNewThread(null, "Closing window " + w.getTitle());			/*if (ownerModule!=null) {				if (getOwnerModule().isDoomed() || disposing)					return;				if (autoShow && noWindowsShowing(w, ownerModule.getProject())) {					FileCoordinator p = ownerModule.getFileCoordinator();					if (p!=null) 						ownerModule.alert("If you want to close a project, use the Close menu item in the File menu.  Because a project needs at least one window open, a small Project window will be shown.");										ownerModule.windowGoAway(w);					if (p!=null) {						p.doCommand("showWindow","", new CommandRecord(false), CommandChecker.defaultChecker);					}					else						MesquiteMessage.warnProgrammer("file coord null");				}				else 					ownerModule.windowGoAway(w);			}			else {				hide();				dispose();			}			if (autoShow && noWindowsShowing()) {				MesquiteModule.mesquiteTrunk.doCommand("showAbout","", new CommandRecord(false), CommandChecker.defaultChecker);				if (!AlertDialog.query(MesquiteModule.mesquiteTrunk.containerOfModule(), "How to Quit", "If you hadn't intended to quit Mesquite, select \"Go back to Mesquite\"..  Because Mesquite needs at least one window open, the Mesquite window will be shown.  If you want to Force Quit right now, select \"Force Quit\" now (the standard and safer way to quit Mesquite is to select Quit Mesquite from the File menu).", "Go back to Mesquite", "Force Quit"))					MesquiteModule.mesquiteTrunk.doCommand("goAwayForceQuit",null, new CommandRecord(false), CommandChecker.defaultChecker);			}			*/		}		public void windowActivated(WindowEvent e){			if (w !=null) {				activeWindow = w;//for workaround the Mac OS menu disappearance bug after closing a window				if (w.ownerModule !=null && w.ownerModule.getProject() !=null) //so that file save will remember foremost window					w.ownerModule.getProject().activeWindowOfProject = w;			}		}	}		PopUpPanel quickPanel;	public void showQuickMessage( int xPixel, int yPixel,  String message){		showQuickMessage(getGraphicsArea(), null,xPixel, yPixel, message);	}	public void showQuickMessage(Panel panel, int xPixel, int yPixel,  String message){		showQuickMessage(panel, null,xPixel, yPixel, message);	}	public void showQuickMessage(Panel panel, Rectangle rect,int xPixel, int yPixel,  String message){		Rectangle boundingBox = rect;		if (boundingBox==null)			boundingBox = panel.getBounds();		int boxWidth = 96;		if (StringUtil.blank(message))			return;		if (quickPanel==null) {			panel.add(quickPanel = new PopUpPanel());			quickPanel.setBackground(ColorDistribution.sienna);		}		quickPanel.setText(message, panel.getFont(), boxWidth);		int offsetRight = 12;		StringInABox sb = quickPanel.getBox();		int xOffset = boundingBox.x;		int yOffset = boundingBox.y;		int xPos=0;		if (xPixel+boxWidth+8 + offsetRight>boundingBox.width) 			xPos = xPixel-boxWidth + xOffset;		else			xPos = xPixel+4 + xOffset + offsetRight;		int yPos=0;				if (yPixel+sb.getHeight()>boundingBox.height + yOffset && yPixel-sb.getHeight() + yOffset>=0)			yPos = yPixel-sb.getHeight() + yOffset;		else			yPos = yPixel + yOffset;		quickPanel.setSize(boxWidth +2, sb.getHeight() +2);		quickPanel.setLocation(xPos, yPos);		quickPanel.setVisible(true);		quickPanel.repaint();			}	/* ----------------------------------*/	public void hideQuickMessage(MesquiteChart chart){		if (quickPanel!=null)			quickPanel.setVisible(false);	}}class PopUpPanel extends Panel {	String t;	StringInABox sb;	void setText(String s, Font f, int w){		t = s;		sb = new StringInABox(t, f, w);	}	StringInABox getBox(){		return sb;	}	public void paint(Graphics g){		if (sb == null)			return;				sb.drawInBox(g, getBackground(), 3, 1);		g.setColor(Color.black);		g.drawRect(0,0,getBounds().width-1, getBounds().height-1);	}}
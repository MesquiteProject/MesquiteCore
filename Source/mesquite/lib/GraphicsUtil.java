/* Mesquite source code.  Copyright 1997-2009 W. Maddison and D. Maddison.Version 2.6, January 2009.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.lib;import java.awt.*;import java.awt.event.*;import java.awt.image.*;/* ======================================================================== *//** This class provides general graphics utilities */public class GraphicsUtil {	/* ............................................................................................................... */	/** Given the coordinates of the start and end of a line, returns how far along the line (x,y) is */	public static double fractionAlongLine(int x, int y, int xStart, int yStart, int xEnd, int yEnd, boolean xBias, boolean yBias) {		if (xStart==xEnd)  //it's a vertical line or a single point			if (y<=yStart)				return 0.0;			else if (y>=yEnd)				return 1.0;		if (yStart==yEnd)  //it's a vertical line or a single point			if (x<=xStart)				return 0.0;			else if (x>=xEnd)				return 1.0;		if (!MesquiteInteger.contains(x, xStart, xEnd) && !MesquiteInteger.contains(y, yStart, yEnd)) {   //outside the bounds			if ((yEnd>=yStart && y>yEnd) || (yEnd<yStart && y<yEnd))				return 1.0;			if ((xEnd>=xStart && x>xEnd) || (xEnd<xStart && x<xEnd))				return 1.0;			else				return 0.0;		}		if (!MesquiteInteger.contains(y, yStart, yEnd)) // we are not in y range, must use x			return Math.abs(1.0*(x-xStart)/(xEnd-xStart));		if (!MesquiteInteger.contains(x, xStart, xEnd)) // we are not in x range, must use y			return Math.abs(1.0*(y-yStart)/(yEnd-yStart));		if (xBias)			return Math.abs(1.0*(x-xStart)/(xEnd-xStart));		if (yBias)			return Math.abs(1.0*(y-yStart)/(yEnd-yStart));		if (Math.abs(yEnd-yStart) > Math.abs(xEnd-xStart))  // y range larger			return Math.abs(1.0*(y-yStart)/(yEnd-yStart));		return Math.abs(1.0*(x-xStart)/(xEnd-xStart));	}	/* ............................................................................................................... */	/** Given the coordinates of the start and end of a line, returns the value of x at the middle of the line */	public static int xCenterOfLine(int x1, int y1, int x2, int y2) {		if (x1==x2)  //it's a vertical line or a single point			return x1;		return (Math.min(x1, x2) + Math.abs(x1-x2)/2);	}	/* ............................................................................................................... */	/** Given the coordinates of the start and end of a line, returns the value of y at the middle of the line */	public static int yCenterOfLine(int x1, int y1, int x2, int y2) {		if (y1==y2)  //it's a horizontal line or a single point			return y1;		return (Math.min(y1, y2) + Math.abs(y1-y2)/2);	}	/* ............................................................................................................... */	/** Given the coordinates of the start and end of a line, returns the angle in radians of the line */	public static double angleOfLine(int x1, int y1, int x2, int y2) {		if (y1==y2)  //it's a horizontal line or a single point			if (x2>=x1)				return 0.0;			else				return Math.PI;		if (x1==x2)  //it's a vertical line or a single point			if (y2>=y1)				return Math.PI/2.0;			else				return -Math.PI/2.0;		double a = Math.PI -Math.atan(-(y2-y1)*1.0/(x2-x1));  		if (x2>x1)			a = Math.PI+a;		return a;	}	/* ............................................................................................................... */	/** draws a line starting at x,y, and going in the direction of the angle */	public static void drawAngledLine(Graphics g, int x, int y, double angle, int length) {		int endX= (int)(Math.cos(angle)*length)+x;		int endY =(int)(Math.sin(angle)*length)+y;		g.drawLine(x,y,endX, endY);	}	/*	 * 		Graphics2D g2 = (Graphics2D)g;		g2.rotate(-Math.PI/4, x, y);		g2.translate(x, y);		g2.setColor(Color.blue);		g2.fillRect(0, 0, 30, 40);		g2.translate(-x, -y);		g2.rotate(Math.PI/4, x, y);	/* ............................................................................................................... */	/** creates a square beginning at x,y and tilted in the direction of the angle. */	public static void translateAlongAngle(MesquiteInteger x, MesquiteInteger y, double angle, int length) {		int adj= -(int)(Math.cos(angle)*length);		int opp =-(int)(Math.sin(angle)*length);		x.add(adj);		y.add(opp);  	}	/* ............................................................................................................... */	/** creates a square beginning at x,y and tilted in the direction of the angle. */	public static Polygon createAngledSquare(int x, int y, double angle, int length) {		int adj= -(int)(Math.cos(angle)*length);		int opp =-(int)(Math.sin(angle)*length);		x -=opp/2;		y-=adj/2;		Polygon poly = new Polygon();		poly.npoints=0;		poly.addPoint(x,y);		poly.addPoint(x+opp,y+adj);		poly.addPoint(x+opp-adj,y+adj+opp);		poly.addPoint(x-adj,y+opp);		poly.addPoint(x,y);		poly.npoints=5;		return poly;	}	/* ............................................................................................................... */	public static void shimmerVerticalOn(Graphics g, Panel panel, int top, int bottom, int x) {		if (g==null && panel==null)			if (!MesquiteInteger.isCombinable(x))				return;		Graphics mg = g;		if (mg==null)			mg = panel.getGraphics();		if (mg == null)			return;//		mg.setColor(Color.black);		if (GraphicsUtil.useXORMode(g, false)){			mg.setXORMode(Color.white);			mg.drawLine(x, top, x, bottom);		}//		mg.drawLine(x+1, top, x+1, bottom);		if (g==null)			mg.dispose();	}	/* ............................................................................................................... */	public static void shimmerHorizontalOn(Graphics g, Panel panel, int left, int right, int y) {		if (g==null && panel==null)			if (!MesquiteInteger.isCombinable(y))				return;		Graphics mg = g;		if (mg==null)			mg = panel.getGraphics();		if (mg == null)			return;		if (GraphicsUtil.useXORMode(g, false)){			mg.setXORMode(Color.white);			mg.drawLine(left, y, right, y);		}		if (g==null)			mg.dispose();	}	/* -------------------------------------------------*/	public static boolean useXOR = true;	/*Bugs is os x Tiger ca. 10.4.8 can cause crashes with XORMode.  With OS X Tiger, it does not do XORMode with printing or if senstive is on */	public static boolean useXORMode(Graphics g, boolean sensitive){		if (sensitive || g instanceof PrintGraphics){			//if (MesquiteTrunk.isMacOSX()  && System.getProperty("os.version").indexOf("10.4")>=0)			//	return false;			return useXOR;		}		return true;	}	/* -------------------------------------------------*/	public static void fillTransparentSelectionRectangle (Graphics g, int x, int y, int w, int h) {		Composite composite = ColorDistribution.getComposite(g);		ColorDistribution.setTransparentGraphics(g,0.3f);				g.setColor(Color.black);		g.fillRect(x,y,w, h);		ColorDistribution.setComposite(g, composite);			}	/* -------------------------------------------------*/	public static void fillTransparentSelectionPolygon (Graphics g, Polygon poly) {		Composite composite = ColorDistribution.getComposite(g);		ColorDistribution.setTransparentGraphics(g,0.3f);				g.setColor(Color.black);		g.fillPolygon(poly);		ColorDistribution.setComposite(g, composite);			}	/* -------------------------------------------------*/	public static void shadeRectangle (Graphics g, int x, int y, int w, int h, Color color) {		Composite composite = ColorDistribution.getComposite(g);		ColorDistribution.setTransparentGraphics(g,0.2f);				g.setColor(color);		g.fillRect(x,y,w, h);		ColorDistribution.setComposite(g, composite);			}	/* -------------------------------------------------*/	public static void darkenRectangle (Graphics g, int x, int y, int w, int h, float f) {		Composite composite = ColorDistribution.getComposite(g);		ColorDistribution.setTransparentGraphics(g,f);				g.setColor(Color.black);		g.fillRect(x,y,w, h);		ColorDistribution.setComposite(g, composite);			}	/* -------------------------------------------------*/	public static void darkenRectangle (Graphics g, int x, int y, int w, int h) {		darkenRectangle(g,x,y,w,h,0.2f);	}	/* -------------------------------------------------*/	public static void drawRect (Graphics g, int x, int y, int w, int h) {		if (w < 0){			int nx = x + w;			x = nx;			w = -w;		}		if (h < 0){			int ny = y + h;			y = ny;			h = -h;		}		g.drawRect(x, y, w, h);	}	/* -------------------------------------------------*/	public static void setFontName (String name, Graphics g) {		Font curFont = g.getFont();		Font fontToSet = new Font (name, curFont.getStyle(), curFont.getSize());		if (fontToSet!= null) {			curFont = fontToSet;			g.setFont(curFont);		}	}	/* -------------------------------------------------*/	public static void setFontStyle (int style, Graphics g) {		Font curFont = g.getFont();		Font fontToSet = new Font (curFont.getName(), style, curFont.getSize());		if (fontToSet!= null) {			curFont = fontToSet;			g.setFont(curFont);		}	}	/* -------------------------------------------------*/	public static void setFontSize (int size, Graphics g) {		Font curFont = g.getFont();		Font fontToSet = new Font (curFont.getName(), curFont.getStyle(), size);		if (fontToSet!= null) {			curFont = fontToSet;			g.setFont(curFont);		}	}	/* -------------------------------------------------*/	public static void fillOval(Graphics g, int x, int y, int w, int h, boolean threeD){		try {			if (threeD){				Color c = g.getColor();				Color current = c;				current = ColorDistribution.darker(current, 0.75);				while (w>0) {					g.setColor(current);					g.fillOval(x,y,w,h);					x++;					y++;					w-=4;					h-=4;					current = ColorDistribution.brighter(current, 0.75);				}				if (c!=null) g.setColor(c);			}			else				g.fillOval(x,y,w,h); 		}		catch(NullPointerException e){			MesquiteMessage.warnProgrammer("npe in fill oval x " + x + " y " + y + " w " + w + " h " + h);		}	}	/* -------------------------------------------------*/	public static void fillArc(Graphics g, int x, int y, int w, int h, int startAngle, int arcAngle, boolean threeD){		if (arcAngle < 1)			return;		if (MesquiteTrunk.isWindows()){ //this is workaround to Windows problem by which goes all black if too close to 0 or 360			int spotsize = MesquiteInteger.maximum(w, h);			if (3.14*spotsize*(360-arcAngle)/360<1){				fillOval(g, x, y, w, h, threeD);				return;			}			if (3.14*spotsize*arcAngle/360<1)				return;		}		if (threeD){			Color c = g.getColor();			Color current = c;//			TODO: needs to define a polygon that clips to prevent upward curved edges on left side			current = ColorDistribution.darker(current, 0.75);			while (w>0) {				g.setColor(current);				g.fillArc(x,y,w,h, startAngle, arcAngle);				x++;				y++;				w-=4;				h-=4;				current = ColorDistribution.brighter(current, 0.75);			}			if (c!=null) g.setColor(c);		}		else			g.fillArc(x,y,w,h, startAngle, arcAngle); 	}}
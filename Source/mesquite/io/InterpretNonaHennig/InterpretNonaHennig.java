/* Mesquite (package mesquite.io).  Copyright 2000-2006 D. Maddison and W. Maddison. Version 1.11, June 2006.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)28 July 01 (WPM): checked for treeVector == null on export; use getCompatibleFileElements*/package mesquite.io.InterpretNonaHennig;/*~~  */import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.io.lib.*;import mesquite.categ.lib.*;import mesquite.parsimony.lib.*;/* - export trees- quote within XREAD, DREAD- tread   : check to see if format allows named taxa in tree description- handle abbreviations*//*==================================================*//* ============  a file interpreter for NONA files ============*/public class InterpretNonaHennig extends FileInterpreterITree {	ProgressIndicator progIndicator;	Class[] acceptedClasses;	HennigNonaCommand[] availableCommands;/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) {		availableCommands = new HennigNonaCommand[numCommands];		acceptedClasses = new Class[] {CategoricalState.class,ProteinState.class, DNAState.class};		initializeCommands(); 		return true;  //make this depend on taxa reader being found?)  	 }/*.................................................................................................................*/	public String preferredDataFileExtension() { 		return "ss";   	 }/*.................................................................................................................*/	public boolean canExportEver() {  		 return true;  //	}/*.................................................................................................................*/	public boolean canExportProject(MesquiteProject project) {  		 return project.getNumberCharMatrices(acceptedClasses) > 0;  //	}/*.................................................................................................................*/	public boolean canExportData(Class dataClass) {  		 for (int i = 0; i<acceptedClasses.length; i++)		 	if (dataClass==acceptedClasses[i])		 		return true;		 return false; 	}/*.................................................................................................................*/	public boolean canImport() {  		 return true;	}/*.................................................................................................................*/	static final int numCommands = 7;   // number of available commands	static final int cnamesElement = 6;/*.................................................................................................................*/	public void initializeCommands() {  		for (int j = 0; j<numCommands; j++) {			availableCommands[j] = null;			}					availableCommands[0] = new HennigDREAD(this, parser);		availableCommands[1] = new HennigXREAD(this, parser);		availableCommands[2] = new HennigCCODE(this, parser);		availableCommands[3] = new HennigQUOTE(this, parser);		availableCommands[4] = new HennigTREAD(this, parser);		availableCommands[5] = new HennigCOMMENTS(this, parser);		availableCommands[cnamesElement] = new HennigCNAMES(this, parser);	}/*.................................................................................................................*/	public void readTreeFile(MesquiteProject mf, MesquiteFile file, String arguments, CommandRecord commandRec) {		Taxa taxa = getProject().chooseTaxa(containerOfModule(), "Of what taxa are these trees composed?",commandRec);		if (taxa== null) 			return;		incrementMenuResetSuppression();		//file.linkProgressIndicator(progIndicator);		if (file.openReading()) {						parser.setPunctuationString(";");			parser.setQuoteCharacter((char)0);			String line = file.readLine(";");   // reads first line			String command;						boolean abort = false;			while (!StringUtil.blank(line) && !abort) {				parser.setString(line); //sets the string to be used by the parser to "line" and sets the pos to 0				command = parser.getFirstToken(line); //command name				if ((availableCommands[4] != null) && availableCommands[4].canRead(command)) {					availableCommands[4].readCommand(mf,file,null,null,taxa,line, commandRec);				}				line = file.readLine(";");						if (file.getFileAborted()) {					abort = true;				}			}			finishImport(null, file, abort, commandRec);		}		decrementMenuResetSuppression();	}/*.................................................................................................................*/	public void readFile(MesquiteProject mf, MesquiteFile file, String arguments, CommandRecord commandRec) {		incrementMenuResetSuppression();		progIndicator = new ProgressIndicator(mf,"Importing File "+ file.getName(), file.existingLength());		progIndicator.start();		file.linkProgressIndicator(progIndicator);		if (file.openReading()) {						parser.setPunctuationString(";");			parser.setQuoteCharacter((char)0);			String line = file.readLine(";");   // reads first line			String command;						CategoricalData data = null;			Taxa taxa = null;						boolean abort = false;			progIndicator.setText("Reading commands in file of format " + getName());								while (!StringUtil.blank(line) && !abort) {				parser.setString(line); //sets the string to be used by the parser to "line" and sets the pos to 0				command = parser.getFirstToken(line); //command name				progIndicator.setText("Reading command " + command);									for (int j = 0; j<numCommands; j++) {					if ((availableCommands[j] != null) && availableCommands[j].canRead(command)) {						if (availableCommands[j].returnData()) {							data = availableCommands[j].readCommandReturnData(mf, file,progIndicator);							if (data == null) {															discreetAlert(commandRec, "Sorry, the file could not be read.  The log file may indicate reasons.");								abort = true;							}						}						else if (data != null)							availableCommands[j].readCommand(mf,file,progIndicator,data,data.getTaxa(),line, commandRec);						else							availableCommands[j].readCommand(mf,file,progIndicator,null,null,line, commandRec);					}				}				line = file.readLine(";");						if (file.getFileAborted()) {					abort = true;				}			}			progIndicator.setText("Finishing import of file of format " + getName());								finishImport(progIndicator, file, abort, commandRec);		}		decrementMenuResetSuppression();	}	/* ============================  exporting ============================*/	/*.................................................................................................................*/		public boolean getExportOptions(boolean dataSelected, boolean taxaSelected){		setLineDelimiter(WINDOWSDELIMITER);		MesquiteInteger buttonPressed = new MesquiteInteger(1);		ExporterDialog exportDialog = new ExporterDialog(this,containerOfModule(), "Export Nona/Hennig86 Options", buttonPressed);				exportDialog.completeAndShowDialog(dataSelected, taxaSelected);					boolean ok = (exportDialog.query(dataSelected, taxaSelected)==0);				exportDialog.dispose();		return ok;	}		/*.................................................................................................................*/		public boolean getExportOptionsSimple(boolean dataSelected, boolean taxaSelected){   // an example of a simple query, that only proved line delimiter choice; not used here		return (ExporterDialog.query(this,containerOfModule(), "Export Nona/Hennig86 Options")==0);	}			/*.................................................................................................................*/	public CategoricalData findDataToExport(MesquiteFile file, String arguments, CommandRecord commandRec) { 		return (CategoricalData)getProject().chooseData(containerOfModule(), file, null, acceptedClasses, "Select data to export", commandRec);	}/*.................................................................................................................*/	public int getNumExportTotal(Taxa taxa, CategoricalData data) {  		int exportTotalElements = 0;		exportTotalElements+= taxa.getNumTaxa();   // for XREAD		if (data.hasStateNames()|| data.characterNamesExist()) {			exportTotalElements+= data.getNumChars();   // for CNAMES		}		return exportTotalElements;	}	/*.................................................................................................................*/	public void exportFile(MesquiteFile file, String arguments, CommandRecord commandRec) { //if file is null, consider whole project open to export		Arguments args = new Arguments(new Parser(arguments), true);		boolean usePrevious = args.parameterExists("usePrevious");					CategoricalData  data = findDataToExport(file, arguments, commandRec);		if (data ==null) {			showLogWindow(true);			logln("WARNING: No suitable data available for export to a file of format \"" + getName() + "\".  The file will not be written.\n");			return;		}		Taxa taxa = data.getTaxa();		if (!commandRec.scripting() && !usePrevious)			if (!getExportOptions(data.anySelected(), taxa.anySelected())) {				return;			}					int totalProgressElements = getNumExportTotal(taxa, data);		progIndicator = new ProgressIndicator(getProject(),"Exporting File ", totalProgressElements, false);		progIndicator.start();				HennigXDREAD xread = (HennigXDREAD)availableCommands[0];		HennigXDREAD dread = (HennigXDREAD)availableCommands[1];		HennigCCODE ccode = (HennigCCODE)availableCommands[2];		HennigQUOTE quote = (HennigQUOTE)availableCommands[3];  //unused		HennigTREAD tread = (HennigTREAD)availableCommands[4];  // unused		StringBuffer outputBuffer = new StringBuffer(taxa.getNumTaxa()*(20 + data.getNumChars()));		availableCommands[3].appendCommandToStringBuffer(outputBuffer, taxa, data, progIndicator);  //quote		if (data.getStateClass()==DNAData.class)			xread.appendCommandToStringBuffer(outputBuffer, taxa, data, progIndicator);		else			dread.appendCommandToStringBuffer(outputBuffer, taxa, data, progIndicator);		if (data.hasStateNames()|| data.characterNamesExist())			availableCommands[cnamesElement].appendCommandToStringBuffer(outputBuffer, taxa, data, progIndicator);		availableCommands[2].appendCommandToStringBuffer(outputBuffer, taxa, data, progIndicator);  //ccode		if (!args.parameterExists("noTrees"))			availableCommands[4].appendCommandToStringBuffer(outputBuffer, taxa, data, progIndicator);  //trees					outputBuffer.append(getLineEnding()+ "proc /;");			//	outputBuffer.append(getLineEnding());	//	availableCommands[cnamesElement].appendCommandToStringBuffer(outputBuffer, taxa, data, progIndicator);  //character names		outputBuffer.append(getLineEnding());		availableCommands[5].appendCommandToStringBuffer(outputBuffer, taxa, data, progIndicator);  //comments		outputBuffer.append(getLineEnding());				progIndicator.goAway();		saveExportedFileWithExtension(outputBuffer, arguments, "ss", commandRec);	}	/*.................................................................................................................*/    	 public String getName() {		return "NONA, Hennig86, PiWe, WinClada";   	 }	/*.................................................................................................................*/   	  	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Imports and exports NONA/Hennig86/PiWe/WinClada files." ;   	 }	/*.................................................................................................................*/   	    	 }			/*========================================================*/abstract class HennigNonaCommand {	protected  MesquiteModule ownerModule;	public FileInterpreterI fileInterpreter;	public Parser parser;		public HennigNonaCommand(MesquiteModule ownerModule, Parser parser){		fileInterpreter = (FileInterpreterI)ownerModule;		this.ownerModule = ownerModule;		this.parser = parser;	}/*.................................................................................................................*/	public abstract String getCommandName();   // returns the command name/*.................................................................................................................*/	public  boolean canRead(String s){		boolean can;		if (s.length()<getCommandName().length()) {			String shortCommandName = getCommandName().substring(0,s.length());			can = getCommandName().equalsIgnoreCase(s) || shortCommandName.equalsIgnoreCase(s);		}		else			can = getCommandName().equalsIgnoreCase(s);		return can;	}/*.................................................................................................................*/	public abstract boolean returnData();/*.................................................................................................................*/	public boolean readCommand(MesquiteProject mp, MesquiteFile file, ProgressIndicator progIndicator, CategoricalData data, Taxa taxa, String firstLine, CommandRecord commandRec){		return false;	}/*.................................................................................................................*/	public CategoricalData readCommandReturnData(MesquiteProject mp, MesquiteFile file, ProgressIndicator progIndicator){		return null;	}/*.................................................................................................................*/	public void incrementAndUpdateProgIndicator(ProgressIndicator progIndicator, String s){		if (progIndicator!=null) {			progIndicator.setCurrentValue(progIndicator.getCurrentValue()+1);			progIndicator.setText(s);		}	}/*.................................................................................................................*/	public void appendCommandToStringBuffer(StringBuffer outputBuffer, Taxa taxa, CategoricalData data, ProgressIndicator progIndicator){	}}/*========================================================*//*.................................................................................................................*/class HennigCCODE extends HennigNonaCommand {	CharWeightSet weightSet = null;	CharacterModel additive = null; 	CharacterModel nonadditive = null;	ParsimonyModelSet modelSet= null;	CharInclusionSet inclusionSet = null;		public HennigCCODE (MesquiteModule ownerModule, Parser parser){		super(ownerModule, parser);	}/*.................................................................................................................*/	public boolean returnData(){		return false;	}/*.................................................................................................................*/	public  String getCommandName(){		return "ccode";	}/*.................................................................................................................*/	public boolean readCommand(MesquiteProject mp, MesquiteFile file, ProgressIndicator progIndicator, CategoricalData data, Taxa taxa, String firstLine){/*		[ 	make following characters active   		]	make following characters inactive;  i.e., exclude		- 	make following characters nonadditive;  i.e., unordered		+	make following characters additive;   i.e., ordered		/N	set weight to number N, then apply to following characters	        *     discard all previous specifiers	        =N	set internal steps to number N, then apply to following characters, not supported by Mesquite*/     /*    	scopes work as follows:  character numbers are used, with a . representing "to".  		if . is used, without a number on one side, represents end of matrix 		zero based.		e.g.,		3	character 3 		.3	characters 0-3		3.	characters 3 to the end of the matrix		3.7	characters 3 through 7 inclusive*/ 		 		//weights 		if (weightSet ==null) { 			weightSet= new CharWeightSet("Imported Weight Set", data.getNumChars(), data);  // making a weight set 			weightSet.addToFile(ownerModule.getProject().getHomeFile(), ownerModule.getProject(), ownerModule.findElementManager(CharWeightSet.class)); //attaching the weight set to a file			data.setCurrentSpecsSet(weightSet, CharWeightSet.class); 			 			//types			additive = ownerModule.getProject().getCharacterModel("ord");	 		nonadditive = ownerModule.getProject().getCharacterModel("unord");			modelSet= new ParsimonyModelSet("Imported Model Set", data.getNumChars(), additive,data);  // making a parsimony set	 		modelSet.addToFile(ownerModule.getProject().getHomeFile(), ownerModule.getProject(), ownerModule.findElementManager(ParsimonyModelSet.class)); //attaching the type set to a file			data.setCurrentSpecsSet(modelSet, ParsimonyModelSet.class);  						//inclusion exclusion	 		inclusionSet= new CharInclusionSet("Imported Inclusion Set", data.getNumChars(), data);  // making an inclusion set	 		inclusionSet.addToFile(ownerModule.getProject().getHomeFile(), ownerModule.getProject(), ownerModule.findElementManager(CharInclusionSet.class)); //attaching the inclusion set to a file			data.setCurrentSpecsSet(inclusionSet, CharInclusionSet.class);  			inclusionSet.selectAll();		}				boolean makeActive = true;		boolean makeInactive = false;		boolean makeNonAdditive = false;		boolean makeAdditive = true;		boolean setWeight = false;		int weightToSet = 1;		int scopeStart = 0;		int scopeEnd = data.getNumChars()-1;				parser.setPunctuationString("*-+[]/");		String token;		progIndicator.setText("Reading CCODE");		token = parser.getNextToken();		while (!StringUtil.blank(token)) {			if ("[".equals(token)) makeActive = true;			else if ("]".equals(token)) makeInactive = true;			else if ("-".equals(token)) makeNonAdditive = true;			else if ("+".equals(token)) makeAdditive = true;			else if ("*".equals(token)) {				makeActive = true;				makeInactive = false;				makeNonAdditive = false;				makeAdditive = true;				setWeight = false;			}			else if ("/".equals(token)) {				token = parser.getNextToken();				weightToSet = MesquiteInteger.fromString(token);				setWeight=true;			}			else if ("=".equals(token)) {				token = parser.getNextToken();				MesquiteTrunk.mesquiteTrunk.alert("Sorry, Mesquite does not support setting of internal steps in NONA files.");			}			else  { // it is a scope, we need to process it				scopeStart = 0;				scopeEnd = data.getNumChars()-1;				if (token.indexOf(".")<0) {// it's just a single character					scopeStart = MesquiteInteger.fromString(token);					scopeEnd = scopeStart;				}				else if (".".equals(token)) {  // it's just at dot					scopeStart = 0;					scopeEnd = data.getNumChars()-1;				}				else if (token.charAt(0) =='.') {  // it's at the start					scopeStart = 0;					scopeEnd = MesquiteInteger.fromString(token.substring(1, token.length()));				}				else if (token.charAt(token.length()-1) =='.') {  // it's at the end					scopeStart = MesquiteInteger.fromString(token.substring(0, token.length()-1));					scopeEnd = data.getNumChars()-1;				}				else  {  // it's in the middle					scopeStart = MesquiteInteger.fromString(token.substring(0, token.indexOf(".")));					scopeEnd = MesquiteInteger.fromString(token.substring(token.indexOf(".")+1, token.length()));				}				for (int ic=scopeStart; ic<=scopeEnd; ic++) {   // setting the values of each character in the scope					if (makeAdditive) modelSet.setModel(additive, ic);					if (makeNonAdditive) modelSet.setModel(nonadditive, ic);					if (setWeight) weightSet.setValue(ic, weightToSet);					if (makeActive) inclusionSet.setSelected(ic, true);					if (makeInactive) inclusionSet.setSelected(ic, false);				}			}			token = parser.getNextToken();		}		parser.setPunctuationString(";");		return true;	}/*.................................................................................................................*/	private String scopeToString(int scopeStart, int scopeEnd) {		String s =" "+scopeStart;		if (scopeEnd==scopeStart+1)			s+=" "+scopeEnd;		else if (scopeEnd>scopeStart+1)			s+="."+scopeEnd;		return s;	}/*.................................................................................................................*/	public void appendCommandToStringBuffer(StringBuffer outputBuffer, Taxa taxa, CategoricalData data, ProgressIndicator progIndicator){		int numChars = data.getNumChars();		String ccode="";		//writing the character weights		CharWeightSet weightSet = (CharWeightSet) data.getCurrentSpecsSet(CharWeightSet.class); 		CharInclusionSet processedSet= new CharInclusionSet("", data.getNumChars(), data); // temporary specset		for (int ic=0; ic<numChars; ic++) 			processedSet.setSelected(ic, false);				int ic = 0;		int scopeStart;		int icWeight = 1;		String ccodePart = "";		int counter = 0;		int writeCounter =0;		if (weightSet != null)			while (ic< numChars) {				if (!fileInterpreter.writeOnlySelectedData || (data.getSelected(ic))) {					icWeight = weightSet.getInt(ic);					if (icWeight!=1 && !processedSet.isSelected(ic)) {						processedSet.setSelected(ic, true);   // marks this one as already chosen						ccodePart+=" /"+icWeight + " ";						scopeStart= counter;						boolean foundFirstBreak = false;						for (int icFollow=ic+1; icFollow<numChars; icFollow++) {							if (!fileInterpreter.writeOnlySelectedData || (data.getSelected(icFollow))) {								writeCounter++; 								if (weightSet.getInt(icFollow)==icWeight && !processedSet.isSelected(icFollow))  {									processedSet.setSelected(icFollow, true);									if (scopeStart==-1) {										scopeStart=counter;									}									if ((icFollow==numChars-1 && !fileInterpreter.writeOnlySelectedData)||(icFollow==data.lastSelected() && fileInterpreter.writeOnlySelectedData)) {										ccodePart += scopeToString(scopeStart, writeCounter);										if (!foundFirstBreak)											ic=numChars;									}								}								else if (scopeStart>=0) {   // we've found a break, write previous scope									ccodePart += scopeToString(scopeStart, writeCounter-1);									scopeStart=-1;									if (!foundFirstBreak) {										foundFirstBreak = true;										ic = icFollow-1;									}																	}							}						}					}					counter++;					writeCounter = counter;				}				ic ++;			}				if (ccodePart!="")			ccode += ccodePart+" *";		ccodePart = "";		//now to write which characters are unordered (non-additive)		ParsimonyModelSet modelSet= (ParsimonyModelSet)data.getCurrentSpecsSet(ParsimonyModelSet.class);		boolean firstTime=true;		ic = 0;		counter = 0;		if (modelSet!=null)			while (ic<numChars) {				if (!fileInterpreter.writeOnlySelectedData || (data.getSelected(ic))) {					if ("unordered".equalsIgnoreCase(modelSet.getModel(ic).getName())) {						if (firstTime) {							ccodePart+=" - ";							firstTime=false;						}						scopeStart=counter;						while (ic<numChars && (("unordered".equalsIgnoreCase(modelSet.getModel(ic).getName())) ||  (fileInterpreter.writeOnlySelectedData || (!data.getSelected(ic)))  )) {							ic++;							if (!fileInterpreter.writeOnlySelectedData || (data.getSelected(ic)))								counter++;						}						if (ic>=numChars-1 && !fileInterpreter.writeOnlySelectedData)							ccodePart += scopeToString(scopeStart, numChars-1);						else if (ic==data.lastSelected() && fileInterpreter.writeOnlySelectedData)							ccodePart += scopeToString(scopeStart, data.lastSelected());						else							ccodePart += scopeToString(scopeStart, counter-1);					}					counter++;				}				ic++;			}//now to write which characters are excluded (inactive)		if (ccodePart!="")			ccode += ccodePart+" *";		ccodePart = "";		 		CharInclusionSet inclusionSet= (CharInclusionSet)data.getCurrentSpecsSet(CharInclusionSet.class);		firstTime=true;		ic = 0;		counter = 0;		if (inclusionSet!=null)			while (ic<numChars) {				if (!fileInterpreter.writeOnlySelectedData || (data.getSelected(ic))) {					if (!inclusionSet.isSelected(ic)) {						if (firstTime) {							ccodePart+=" ] ";							firstTime=false;						}						scopeStart=counter;						while (ic<numChars && ((!inclusionSet.isSelected(ic)) ||  (fileInterpreter.writeOnlySelectedData || (!data.getSelected(ic)))  )) {							ic++;							if (!fileInterpreter.writeOnlySelectedData || (data.getSelected(ic)))								counter++;						}						if (ic>=numChars-1 && !fileInterpreter.writeOnlySelectedData)							ccodePart += scopeToString(scopeStart, numChars-1);						else if (ic==data.lastSelected() && fileInterpreter.writeOnlySelectedData)							ccodePart += scopeToString(scopeStart, data.lastSelected());						else							ccodePart += scopeToString(scopeStart, counter-1);					}					counter++;				}				ic++;			}				ccode += ccodePart;		if (!StringUtil.blank(ccode)) {			outputBuffer.append(getCommandName()+"\t");			outputBuffer.append(ccode);			outputBuffer.append(";"+ fileInterpreter.getLineEnding()+ fileInterpreter.getLineEnding());		}	}}/*========================================================*//*.................................................................................................................*/class HennigQUOTE extends HennigNonaCommand {	public HennigQUOTE (MesquiteModule ownerModule, Parser parser){		super(ownerModule, parser);	}/*.................................................................................................................*/	public boolean returnData(){		return false;	}/*.................................................................................................................*/	public  String getCommandName(){		return "quote";	}/*.................................................................................................................*/	public boolean readCommand(MesquiteProject mp, MesquiteFile file, ProgressIndicator progIndicator, CategoricalData data, Taxa taxa, String firstLine){ 				int pos = firstLine.indexOf("quote");		if (pos>=0) {			firstLine = firstLine.substring(pos+6, firstLine.length());		} 		file.setAnnotation(firstLine, false);		return true;	}/*.................................................................................................................*/	public void appendCommandToStringBuffer(StringBuffer outputBuffer, Taxa taxa, CategoricalData data, ProgressIndicator progIndicator){		if (!StringUtil.blank(data.getAnnotation())) {			outputBuffer.append(getCommandName()+" ");			outputBuffer.append(data.getAnnotation());			outputBuffer.append(";"+ fileInterpreter.getLineEnding()+ fileInterpreter.getLineEnding());		}	}}/*========================================================*//*.................................................................................................................*/class HennigCNAMES extends HennigNonaCommand {	public HennigCNAMES (MesquiteModule ownerModule, Parser parser){		super(ownerModule, parser);	}/*.................................................................................................................*/	public boolean returnData(){		return false;	}/*.................................................................................................................*/	public  String getCommandName(){		return "cnames";	}/*.................................................................................................................*/	public boolean readCommand(MesquiteProject mp, MesquiteFile file, ProgressIndicator progIndicator, CategoricalData data, Taxa taxa, String firstLine){		parser.setPunctuationString("{;");		int charNumber = 0;		String line = firstLine;		String token;		progIndicator.setText("Reading character and state names");		while (!StringUtil.blank(line)) {				token = parser.getNextToken();				if (token==";") 					return true;				else {    // info for this character					token = parser.getNextToken();					if (token=="+")						charNumber++;					else {						charNumber = MesquiteInteger.fromString(token);						if ((charNumber>=0)&&(charNumber<=data.getNumChars())) {							token = parser.getNextToken();							if (token != "_")								data.setCharacterName(charNumber,token);							if ((token !=";") && (token != null)) {								token = parser.getNextToken();								if ((token !=";") && (token != null)) {									int stateNumber = 0;									while ((token !=";") && (token != null)) {										if (token != "_") 											((CategoricalData)data).setStateName(charNumber, stateNumber, token);										token = parser.getNextToken();										stateNumber ++;									}								}							}																				}					}				}				line = file.readLine(";");				parser.setString(line);			}		parser.setPunctuationString(";");		return true;	}/*.................................................................................................................*/	public void appendCommandToStringBuffer(StringBuffer outputBuffer, Taxa taxa, CategoricalData data, ProgressIndicator progIndicator){		outputBuffer.append(getCommandName()+fileInterpreter.getLineEnding());		int numChars = data.getNumChars();		int counter = 0;				for (int ic = 0; ic<numChars; ic++) {						if ((!fileInterpreter.writeOnlySelectedData || (data.getSelected(ic)))&&(data.characterHasName(ic)||data.hasStateNames(ic))) {				incrementAndUpdateProgIndicator(progIndicator,"Exporting character and state names");				outputBuffer.append("{"+counter+" ");				if (data.characterHasName(ic))					outputBuffer.append(StringUtil.tokenize(data.getCharacterName(ic),";"));				else if (data.hasStateNames(ic))					outputBuffer.append(StringUtil.tokenize("Character_" + (ic+1),";"));								if (data.hasStateNames(ic)) {					for (int stateNumber = 0; stateNumber<=data.maxStateWithName(ic); stateNumber++) {						if (data.hasStateName(ic,stateNumber))							outputBuffer.append(" " + StringUtil.tokenize(data.getStateName(ic,stateNumber),";"));						else							outputBuffer.append(" " + "_");					}				}				outputBuffer.append(";" + fileInterpreter.getLineEnding());			}			if (!fileInterpreter.writeOnlySelectedData || data.getSelected(ic))				counter++;		}						outputBuffer.append(";"+ fileInterpreter.getLineEnding()+ fileInterpreter.getLineEnding());	}}/*========================================================*//*.................................................................................................................*/class HennigCOMMENTS extends HennigNonaCommand {	public HennigCOMMENTS (MesquiteModule ownerModule, Parser parser){		super(ownerModule, parser);	}/*.................................................................................................................*/	public boolean returnData(){		return false;	}/*.................................................................................................................*/	public  String getCommandName(){		return "comments";	}/*.................................................................................................................*/	public boolean readCommand(MesquiteProject mp, MesquiteFile file, ProgressIndicator progIndicator, CategoricalData data, Taxa taxa, String firstLine){		parser.setPunctuationString("{;");		String line = firstLine;		String token;		progIndicator.setText("Reading comments");		while (!StringUtil.blank(line)) {				token = parser.getNextToken(); //getting				if (token==";") 					return true;				else {    // info for this character					if (!("{".equals(token))){						token = parser.getNextToken(); //getting					}											token = parser.getNextToken();					int taxonNumber = MesquiteInteger.fromString(token);						if ((taxonNumber>=0)&&(taxonNumber<=taxa.getNumTaxa())) {							token = parser.getNextToken(); //taxon number							int charNumber = MesquiteInteger.fromString(token);							if ((charNumber>=0)&&(charNumber<=data.getNumChars())) {								token = parser.getRemaining(); 								if ((token !=";") && (token != null)) {									data.setAnnotation(charNumber, taxonNumber, token);								}							}													}				}				line = file.readLine(";");				parser.setString(line);			}		parser.setPunctuationString(";");		return true;	}/*.................................................................................................................*/	public void appendCommandToStringBuffer(StringBuffer outputBuffer, Taxa taxa, CategoricalData data, ProgressIndicator progIndicator){		int numChars = data.getNumChars();		int numTaxa = taxa.getNumTaxa();		int counter = 0;		int startPos = outputBuffer.length();				incrementAndUpdateProgIndicator(progIndicator,"Exporting comments");		for (int it = 0; it<numTaxa; it++){			counter = 0;			for (int ic = 0; ic<numChars; ic++) {				if (!fileInterpreter.writeOnlySelectedData || (data.getSelected(ic))) {					String note = data.getAnnotation(ic, it);					if (note !=null){						outputBuffer.append("{"+it+" " + counter + " ");						outputBuffer.append(note);						outputBuffer.append(";" + fileInterpreter.getLineEnding());					}												counter++;				}			}		}						outputBuffer.insert(startPos, getCommandName()+ " " + counter + fileInterpreter.getLineEnding());		outputBuffer.append(";"+ fileInterpreter.getLineEnding()+ fileInterpreter.getLineEnding());	}}/*========================================================*//*.................................................................................................................*/abstract class HennigXDREAD extends HennigNonaCommand {	public HennigXDREAD (MesquiteModule ownerModule, Parser parser){		super(ownerModule, parser);	}/*.................................................................................................................*/	public boolean returnData(){		return true;	}/*.................................................................................................................*/	public abstract CharacterData createData(CharactersManager charTask, Taxa taxa);/*.................................................................................................................*/	public abstract boolean readStartXDREAD(Parser parser);/*.................................................................................................................*/	public CategoricalData readCommandReturnData(MesquiteProject mp, MesquiteFile file, ProgressIndicator progIndicator){		TaxaManager taxaTask = (TaxaManager)ownerModule.findElementManager(Taxa.class);		 CharactersManager charTask = (CharactersManager)ownerModule.findElementManager(CharacterData.class);				Taxa taxa = taxaTask.makeNewTaxa("Untitled Taxa", 0, false);		taxa.addToFile(file, ownerModule.getProject(), taxaTask);				InterpretNonaHennig interpretHN = (InterpretNonaHennig)ownerModule;		CategoricalData newData = (CategoricalData)createData(charTask,taxa);		if (newData==null) 			return null;				newData.saveChangeHistory = false;		newData.addToFile(file, ownerModule.getProject(), null);				if (! readStartXDREAD(parser))			return null;		String token;		char c;		c = parser.nextDarkChar();		if (c=='\'')  {   // we have a leading quote in the XREAD command			int linePos = parser.getPosition();			c = parser.nextDarkChar();			while (c!='\'' && c!='\0') {   // TODO: check if at end				c = parser.nextDarkChar();			}			String quote = parser.getString().substring(linePos,parser.getPosition()-1);  // saving entire quoted section  TODO: place in appropriate place			newData.setAnnotation(quote, false);		}		else {   //need to backtrack			 parser.setPosition(parser.getPosition()-1);		}				int numTaxa = 0;		int numChars = 0;		token = parser.getNextToken();  // numchars		numChars = MesquiteInteger.fromString(token);		token = parser.getNextToken();  // numTaxa		numTaxa = MesquiteInteger.fromString(token);		boolean wassave = newData.saveChangeHistory;		newData.saveChangeHistory = false;		try {			taxa.addTaxa(-1, numTaxa, true);			newData.addParts(-1, numChars);		}		catch (OutOfMemoryError e){			MesquiteMessage.warnProgrammer("Sorry, the file could not be read (OutOfMemoryError).  See file memory.txt in the Mesquite_Folder.");			return null;		}				for (int it=0; it<numTaxa; it++) {				token = parser.getNextToken();				if (token == ";") 					return newData;				Taxon t = taxa.getTaxon(it);				if (t!=null) {					t.setName(token);					progIndicator.setText("Reading taxon: "+token);					for (int ic=0; ic<numChars; ic++) {						c=parser.nextDarkChar();						if (c==';' || c=='\0') 							return newData;						else {							if (c=='[') {								long set = 0;								c=parser.nextDarkChar();								while ((c!=']' && c!='\0')) {									long newSet = newData.fromChar(c);									set += newSet;									c=parser.nextDarkChar();								}								newData.setState(ic, it, set);							}							else								newData.setState(ic, it, c);    // setting state to that specified by character c						}					}				}			}		newData.saveChangeHistory = wassave;		newData.resetChangedSinceSave();		return newData;	}/*.................................................................................................................*/	public void appendStateToBuffer(int ic, int it, StringBuffer outputBuffer, CategoricalData data){		data.statesIntoStringBuffer(ic, it, outputBuffer, false);	}/*.................................................................................................................*/	public void appendCommandToStringBuffer(StringBuffer outputBuffer, Taxa taxa, CategoricalData data, ProgressIndicator progIndicator){		int numTaxa = taxa.getNumTaxa();		int numChars = data.getNumChars();				outputBuffer.append(getCommandName()+fileInterpreter.getLineEnding());		int numCharWrite = data.numberSelected(fileInterpreter.writeOnlySelectedData);		int numTaxaWrite = taxa.numberSelected(fileInterpreter.writeOnlySelectedTaxa);		outputBuffer.append(Integer.toString(numCharWrite)+" ");		outputBuffer.append(Integer.toString(numTaxaWrite)+fileInterpreter.getLineEnding());				for (int it = 0; it<numTaxa; it++){			if (!fileInterpreter.writeOnlySelectedTaxa || (taxa.getSelected(it))){				incrementAndUpdateProgIndicator(progIndicator,"Exporting data matrix");				outputBuffer.append(StringUtil.tokenize(taxa.getTaxonName(it),";") + "\t");				for (int ic = 0; ic<numChars; ic++) {					if (!fileInterpreter.writeOnlySelectedData || (data.getSelected(ic))){						appendStateToBuffer(ic, it, outputBuffer, data);					}				}				outputBuffer.append(fileInterpreter.getLineEnding());			}		}		outputBuffer.append(";"+ fileInterpreter.getLineEnding()+ fileInterpreter.getLineEnding());	}}/*========================================================*//*.................................................................................................................*/class HennigDREAD extends HennigXDREAD {	public HennigDREAD (MesquiteModule ownerModule, Parser parser){		super(ownerModule, parser);	}/*.................................................................................................................*/	public  String getCommandName(){		return "dread";	}/*.................................................................................................................*/	public void appendStateToBuffer(int ic, int it, StringBuffer outputBuffer, CategoricalData data){		data.statesIntoStringBuffer(ic, it, outputBuffer, false);	}/*.................................................................................................................*/	public boolean readStartXDREAD(Parser parser){		String token = parser.getNextToken();		if (token==null || !token.equalsIgnoreCase("GAP")) {			ownerModule.logln("GAP subcommand could not be found.");			return false;		}		char c = parser.nextDarkChar();  // ? if treat gap as missing, or ; if treat as fifth base		token = parser.getNextToken();		if (token==null || !token.equalsIgnoreCase("MATCH")) {			ownerModule.logln("MATCH subcommand could not be found.");			return false;		}		 c = parser.nextDarkChar();  //ее set matchchar to this, set matchcharon;		 return true;	}/*.................................................................................................................*/	public CharacterData createData(CharactersManager charTask, Taxa taxa) {  		 return charTask.newCharacterData(taxa, 0, "DNA Data");  //	}}/*========================================================*//*.................................................................................................................*/class HennigXREAD extends HennigXDREAD {	public HennigXREAD (MesquiteModule ownerModule, Parser parser){		super(ownerModule, parser);	}/*.................................................................................................................*/	public  String getCommandName(){		return "xread";	}/*.................................................................................................................*/	public boolean readStartXDREAD(Parser parser){		return true;	}/*.................................................................................................................*/	public void appendStateToBuffer(int ic, int it, StringBuffer outputBuffer, CategoricalData data){   		outputBuffer.append(statesToStringDefaultSymbols(data, ic,it,'[',']'));	}/*.................................................................................................................*/	public CharacterData createData(CharactersManager charTask, Taxa taxa) {  		 return charTask.newCharacterData(taxa, 0, "Standard Categorical Data");  //	}	/*..........................................  CategoricalData  ..................................................*/   	/** returns string describing the state(s) of character ic in taxon it.  Uses default symbols, and uses separators    		between states in polymorphic (andSep) or partially uncertain (orSep) taxa.     		Uses leftBracket and rightBracket to bound entries with multiple symbols    		USED BY NONA HENNIG EXPORT*/	public String statesToStringDefaultSymbols(CategoricalData data, int ic,int it, char leftBracket, char rightBracket, char andSep, char orSep){		long s =data.getState(ic, it);		//matrix[ic][it];		boolean first=true;		char sep = andSep;		if (CategoricalState.isUncertain(s))			sep = orSep;		String stateString="";		if (s==CategoricalState.inapplicable) 			return stateString+data.getInapplicableSymbol();		else if (s==CategoricalState.unassigned) 			return stateString+data.getUnassignedSymbol(); 		else if (CategoricalState.cardinality(s)>1) {			stateString = "" + leftBracket;			for (int e=0; e<=CategoricalState.maxCategoricalState; e++) {				if (CategoricalState.isElement(s,e)) {					if ((!first) && (sep!=Character.UNASSIGNED))						stateString+=sep;					stateString += data.getDefaultStateSymbol(e);					first = false;				}			}			stateString += rightBracket;			return stateString;		}		else			return stateString+data.getDefaultStateSymbol(CategoricalState.minimum(s));	}	/*..........................................  CategoricalData  ..................................................*/   	/** returns string describing the state(s) of character ic in taxon it.  Uses default symbols, and uses no separators    		between states in polymorphic or partially uncertain taxa.  Uses leftBracket and rightBracket to    		bound entries with multiple symbols    		USED BY NONA HENNIG EXPORT*/	public String statesToStringDefaultSymbols(CategoricalData data, int ic,int it, char leftBracket, char rightBracket){		return statesToStringDefaultSymbols(data, ic,it, leftBracket, rightBracket,(char)Character.UNASSIGNED, (char)Character.UNASSIGNED);	}}/*========================================================*//*.................................................................................................................*/class HennigTREAD extends HennigNonaCommand {	Parser treeParser;	public HennigTREAD (MesquiteModule ownerModule, Parser parser){		super(ownerModule, parser);		treeParser =  new Parser();	}/*.................................................................................................................*/	public boolean returnData(){		return false;	}/*.................................................................................................................*/	public  String getCommandName(){		return "tread";	}/*.................................................................................................................*/	public boolean readCommand(MesquiteProject mp, MesquiteFile file, ProgressIndicator progIndicator, CategoricalData data, Taxa taxa, String firstLine, CommandRecord commandRec){		String line = firstLine;		treeParser.setQuoteCharacter((char)0);		String lowerLine = line.toLowerCase();		int treadpos = lowerLine.indexOf("tread"); //TODO: this is case sensitive!!!!		if (treadpos>=0) 			line = line.substring(treadpos+5, line.length());		if (taxa == null)			taxa = mp.chooseTaxa(ownerModule.containerOfModule(), "Of what taxa are these trees composed?",commandRec);		String token;		String quote = null;		char c;		int linePos;		parser.setString(line);		TreeVector trees = null;		int counter = 0;		long totalLength = line.length();		ProgressIndicator progress = null;		if (progIndicator==null) {			progress=new ProgressIndicator(mp,"Importing Trees "+ file.getName(), totalLength);			progress.start();		}		while (!StringUtil.blank(line)) {			parser.setString(line);			c = parser.nextDarkChar();			if ((counter==0) && (c=='\'' && c!='\0'))  {   // we have a leading quote in the TREAD command				linePos = parser.getPosition();				c = parser.nextDarkChar();				while (c!='\'' && c!='\0') {					c = parser.nextDarkChar();				}				quote = line.substring(linePos,parser.getPosition()-1);  // saving entire quoted section  TODO: place in trees block				line = line.substring(parser.getPosition()+1, line.length());  // removing first quote				parser.setString(line);				//parser.setPosition(0);			}				if (progIndicator==null) {				progress.setCurrentValue(totalLength-line.length());				progress.setText("Reading tree " + (++counter));			}			else				progIndicator.setText("Reading tree " + (++counter));						if (c==';' || c=='\0') {				return true;			}			else {    // info for this tree				int star = line.indexOf("*");				String treeDescription = null;				if (star>0) {					treeDescription = line.substring(0, star);					line = line.substring(star+1, line.length());				}				else  {					treeDescription = line;					line = null;				}				if (!StringUtil.blank(treeDescription) && treeDescription.indexOf("(")>=0){					if (trees == null) {						trees = new TreeVector(taxa);						trees.setName("Imported trees");						if (quote != null)							trees.setAnnotation(quote, false);					}					MesquiteTree t = new MesquiteTree(taxa);					MesquiteInteger pos = new MesquiteInteger(0);					treeParser.setString(treeDescription);					readClade(t, t.getRoot());					t.setAsDefined(true);					t.setName("Imported tree " + counter);					trees.addElement(t, false);				}			}		}		if (trees!=null)			trees.addToFile(file,file.getProject(),ownerModule.findElementManager(TreeVector.class));		if (progress!=null) 			progress.goAway();		return true;	}	/*...............................................  read tree ....................................................*/	/** Continues reading a tree description, starting at node "node" and the given location on the string*/	private boolean readClade(MesquiteTree tree, int node) {		// from BasicTreeWindowMaker in Minimal					String c = treeParser.getNextToken();		if ("(".equals(c)){  //internal node			int sprouted = tree.sproutDaughter(node, false);			readClade(tree, sprouted);			boolean keepGoing = true;			while (keepGoing) {				int loc = treeParser.getPosition();				String next = treeParser.getNextToken();				if (")".equals(next))					keepGoing = false;				else {					treeParser.setPosition(loc);					sprouted = tree.sproutDaughter(node, false);					keepGoing = readClade(tree, sprouted);				}			}			return true;		}		else if (")".equals(c)) {			return false;		}	  	else {			int taxonNumber = MesquiteInteger.fromString(c);			if (taxonNumber <0 || !MesquiteInteger.isCombinable(taxonNumber)) 				taxonNumber = tree.getTaxa().whichTaxonNumber(c); 			if (taxonNumber >=0 && MesquiteInteger.isCombinable(taxonNumber)){ //taxon successfully found				if (tree.nodeOfTaxonNumber(taxonNumber)<=0){  // first time taxon encountered					tree.setTaxonNumber(node, taxonNumber, false);				 	return true;				 }			 }			return false;	  	}	  		}/*.................................................................................................................*/	public void appendCommandToStringBuffer(StringBuffer outputBuffer, Taxa taxa, CategoricalData data, ProgressIndicator progIndicator){		Listable[] treeVectors = fileInterpreter.getProject().getCompatibleFileElements(TreeVector.class, taxa);		TreeVector treeVector;		if (treeVectors.length==0)			return;		if (treeVectors.length==1)			treeVector = (TreeVector)treeVectors[0];		else			treeVector = (TreeVector)ListDialog.queryList(fileInterpreter.containerOfModule(), "Include trees in file?", "Include trees in file?", MesquiteString.helpString, treeVectors, 0);		Tree tree;		if (treeVector !=null && treeVector.size()>0) {			outputBuffer.append(getCommandName()+fileInterpreter.getLineEnding());			for (int iTree = 0; iTree < treeVector.size(); iTree++) {				tree = (Tree)treeVector.elementAt(iTree);				outputBuffer.append(tree.writeTree(Tree.BY_NUMBERS, false, false, false, true, null));  //or Tree.BY_NUMBERS  or Tree.BY_NAMES				// if do it BY_NAMES, make sure you truncate the taxon names to 10 characters!!				outputBuffer.append("*"+fileInterpreter.getLineEnding());			}			outputBuffer.append(";"+ fileInterpreter.getLineEnding()+ fileInterpreter.getLineEnding());		}	}}
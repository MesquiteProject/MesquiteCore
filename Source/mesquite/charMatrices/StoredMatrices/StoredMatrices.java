/* Mesquite source code.  Copyright 1997-2006 W. Maddison and D. Maddison.Version 1.11, June 2006.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.charMatrices.StoredMatrices;/*~~  */import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;/** Supplies character matrices stored in the project.*/public class StoredMatrices extends CharMatrixSource implements MesquiteListener {	Taxa taxa=null;	CharacterData data;	MCharactersDistribution states;	Class dataClass = null;	MesquiteString dataName;	MesquiteSubmenuSpec mss;	boolean iveQuit = false; //need special means to quit if multiple taxa blocks, because then harder to know on startup if matrices are available	MesquiteBoolean autoQuit;	/*.................................................................................................................*/	/** condition passed to this module must be subclass of CharacterState */	public boolean startJob(String arguments, Object condition, CommandRecord commandRec, boolean hiredByName) { 		autoQuit = new MesquiteBoolean(true);		String sPurpose = whatIsMyPurpose();		if (!StringUtil.blank(sPurpose))			sPurpose = " (" + sPurpose + ")";		else sPurpose = "";		if (condition!=null) {			dataName = new MesquiteString();	 		if (condition instanceof Class)	 			dataClass = (Class)condition;	 		else if (condition instanceof CompatibilityTest)	 			dataClass = ((CompatibilityTest)condition).getAcceptedClass();	 		if (getProject().getNumberCharMatrices(dataClass)<=0 && !MesquiteThread.isScripting()) { //if scripting, matrix might be available later	 			return sorry(commandRec, "There are no stored matrices of the requested type available");	 		}	 		if (getHiredAs() != (CharMatrixObedSource.class)) {	//not hired as a obedient source 				mss = addSubmenu(null, "Stored Matrix" + sPurpose, makeCommand("setDataSet",  this), (ListableVector)getProject().datas);		 		mss.setSelected(dataName);				setDataClass(dataClass);	 		}	 		return true; 		} 		else {	 		if (getProject().getNumberCharMatrices()<=0 && !MesquiteThread.isScripting()) {	 			return sorry(commandRec, "There are no stored matrices available");	 		}			dataName = new MesquiteString();	 		if (getHiredAs() != (CharMatrixObedSource.class)) {	//not hired as a obedient source  				mss = addSubmenu(null, "Stored Matrix" + sPurpose, makeCommand("setDataSet",  this), (ListableVector)getProject().datas);		 		mss.setSelected(dataName);	 		} 		} 		return true;  	 }	/*.................................................................................................................*/  	 private void setDataClass(Class dataClass){		boolean filter = false;		CharacterState cs=null;		try {			cs = (CharacterState)dataClass.newInstance();			filter = true;		}		catch (IllegalAccessException e){alert("iae 17m"); }		catch (InstantiationException e){alert("ie 17m"); }		if (filter && mss != null)			mss.setListableFilter(cs.getCharacterDataClass());  	 }	/*.................................................................................................................*/   	 public boolean isPrerelease(){   	 	return false;   	 }	/*.................................................................................................................*/   	 public boolean isSubstantive(){   	 	return true;   	 }	/*.................................................................................................................*/  	 public CompatibilityTest getCompatibilityTest() {  	 	return new CSMCompatibilityTest();  	 }	/*.................................................................................................................*/  	 public Snapshot getSnapshot(MesquiteFile file) {   	 	Snapshot temp = new Snapshot();  	 	if (taxa!=null && getProject() != null && getProject().getNumberTaxas()>1)  	 		temp.addLine("setTaxa " + getProject().getTaxaReferenceExternal(taxa));  	 	if (data !=null && getProject() != null)  	 		temp.addLine("setDataSet " + getProject().getCharMatrixReferenceExternal(data));  	 	return temp;  	 }	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandRecord commandRec, CommandChecker checker) {    	 	if (checker.compare(this.getClass(), "Sets which stored data matrix to use", "[matrix reference]", commandName, "setDataSet")) { //TODO: filter by dataClass!!!!!    	 		CharacterData d = getProject().getCharacterData(checker.getFile(), taxa, dataClass, parser.getFirstToken(arguments));			if (d==null && commandRec.macro()){ //macro; at this point ask for user to choose   				int which = queryUser(taxa);   				if (MesquiteInteger.isCombinable(which)) {   					d = getProject().getCharacterMatrix(which);   					setMatrix(taxa, d, commandRec);					parametersChanged(null, commandRec);   				}   				else   					return null;			}			else if (d !=null && d!=data) {   				if (taxa == null)   					taxa = d.getTaxa();				setMatrix(taxa, d, commandRec);				parametersChanged(null, commandRec);				resetContainingMenuBar();			}    	 	}    	 	else if (checker.compare(this.getClass(), "Sets which taxa block to use", "[block reference, number, or name]", commandName, "setTaxa")) {    	 		Taxa t = getProject().getTaxa(checker.getFile(), parser.getFirstToken(arguments));   	 		if (t!=null){	   	 		if (taxa!=null)	   	 			taxa.removeListener(this);	   	 		taxa = t;	   	 		if (taxa!=null)	   	 			taxa.addListener(this);				parametersChanged(null, commandRec);				resetContainingMenuBar();	   	 		return taxa;   	 		}    	 	}    	 	else if (checker.compare(this.getClass(), "Sets whether or not to auto-quit when no matrices are available", "[on or off]", commandName, "autoQuit")) {      	 		autoQuit.toggleValue(parser.getFirstToken(arguments));   	 	}    	 	else    	 		return super.doCommand(commandName, arguments, commandRec, checker);		return null;   	 }	/*.................................................................................................................*/	/** passes which object is being disposed (from MesquiteListener interface)*/	public void disposing(Object obj){		if (obj == data && !doomed) {			data.removeListener(this);			if (!autoQuit.getValue()) {				data = null;				return;			}			if (taxa !=null && taxa.isDoomed()) {		 		logln("Taxa null or being disposed; StoredMatrices will quit.");	 			iQuit();	 			return;			}			discreetAlert(CommandRecord.getRecSIfNull(), "A character data matrix in use (for " + getEmployer().getName() + ") has been deleted.  Another matrix will be sought.");			if (dataClass!=null) {		 		if (getProject().getNumberCharMatrices(taxa, dataClass)<=0) {		 			alert("No compatible character matrices were found, and so Stored Matrices cannot be used.");	 				iQuit(false);	 				return;	 			}				data = getProject().getCharacterMatrix(taxa, 0, dataClass);			}			else if (getProject().getNumberCharMatrices(taxa)>0)				data = getProject().getCharacterMatrix(taxa, 0);			else data = null;			if (data==null){		 			alert("No character matrices found, and so Stored Matrices cannot be used.");	 				iQuit(false);	 				return;			}			data.addListener(this);			dataName.setValue(data.getName());			parametersChanged(null, CommandRecord.getRecSIfNull());		}	}	/*.................................................................................................................*/	/** passes which object is being disposed (from MesquiteListener interface)*/	public boolean okToDispose(Object obj, int queryUser){		return true;  //Disposal prohibition not used in Mesquite yet; once used then this should return false if currently in use	}	/*.................................................................................................................*/	public void changed(Object caller, Object obj, Notification notification,  CommandRecord commandRec){		int code = Notification.getCode(notification);		if (obj==data && (code == AssociableWithSpecs.SPECSSET_CHANGED || code == MesquiteListener.VALUE_CHANGED ||code == MesquiteListener.DATA_CHANGED || code == MesquiteListener.PARTS_CHANGED || code == MesquiteListener.PARTS_ADDED || code == MesquiteListener.PARTS_DELETED || code == MesquiteListener.PARTS_MOVED)){			parametersChanged(notification, commandRec);		}	}	/*.................................................................................................................*/    	public  int getNumberOfMatrices(Taxa taxa, CommandRecord commandRec){    		if (getProject()==null)    			return 0;    		else if (dataClass == null)    			return getProject().getNumberCharMatrices(taxa);     		else    			return getProject().getNumberCharMatrices(taxa, dataClass);     	}	/*.................................................................................................................*/	/*.................................................................................................................*/  	public  void setMatrix(Taxa taxa, CharacterData d, CommandRecord commandRec){   		checkCurrentDataSet(taxa, d, commandRec, false);   		this.taxa = taxa;  	}  	  	private int queryUser(Taxa taxa){		int nd = getProject().getNumberCharMatrices(taxa, dataClass);		String[] list = new String[nd];		for (int i=0; i< nd; i++)			list[i]=getProject().getCharacterMatrix(taxa, i, dataClass).getName();		String purposeString = "";		if (!StringUtil.blank(whatIsMyPurpose()))			purposeString = whatIsMyPurpose() + "; ";		return ListDialog.queryList(containerOfModule(), "Use which matrix?", "Use which matrix? \n(" + purposeString + "for " + employer.getName() + ")", MesquiteString.helpString,list, 0);  	}  	   	/** Called to provoke any necessary initialization.  This helps prevent the module's intialization queries to the user from   	happening at inopportune times (e.g., while a long chart calculation is in mid-progress)*/   	public void initialize(Taxa taxa, CommandRecord commandRec){   		checkCurrentDataSet(taxa, null, commandRec, false);   	}   	   	private void setTaxa(Taxa taxa){   		if (this.taxa != taxa && mss != null) {   			mss.setCompatibilityCheck(taxa);   			resetContainingMenuBar();   		}	   	this.taxa = taxa;   	}   	boolean warned = false;	public void checkCurrentDataSet(Taxa taxa, CharacterData proposed, CommandRecord commandRec, boolean warn) {		if (iveQuit)			return;   		setTaxa(taxa);  		if (proposed != null && proposed.getTaxa() == taxa){ //new matrix being proposed  			if (proposed == data)   				return;			dataName.setValue(proposed.getName());			if (data !=null)				data.removeListener(this);			proposed.addListener(this);						data = proposed;		}  		if (getProject() == null)  			return;		if (data == null) { // data == null && proposed == null; need to choose one			if (MesquiteThread.isScripting() || getHiredAs() == CharMatrixObedSource.class) 				data = getProject().getCharacterMatrix(taxa, 0, dataClass);			else if (getProject().getNumberCharMatrices(taxa, dataClass)<=1)				data = getProject().getCharacterMatrix(taxa, 0, dataClass);			else {				int currentDataSet = queryUser(taxa); //ListDialog.queryList(containerOfModule(), "Use which matrix?", "Use which matrix? \n(" + purposeString + "for " + employer.getName() + ")", list, 0);				if (!MesquiteInteger.isCombinable(currentDataSet))					currentDataSet = 0;				data = getProject().getCharacterMatrix(taxa, currentDataSet, dataClass);			}			if (data !=null)				data.addListener(this);			else {   				if (!MesquiteThread.isScripting()){ //if scripting, hope that will soon be fired!   					if (taxa == null)   						alert("There are no appropriate stored character matrices available.");   					else    						alert("There are no appropriate stored character matrices available for the block of taxa (" + taxa.getName() + ").");	   				iveQuit = true;	   				iQuit(false);   				}   			}					} 	}	/*.................................................................................................................*/  	private MCharactersDistribution getM(Taxa taxa, CommandRecord commandRec) {   		setTaxa(taxa);   		checkCurrentDataSet(taxa, null, commandRec, true); //just to insure that OK		if (data!=null) {	   		states = data.getMCharactersDistribution();			return states;	 	}	 	return null;  	}	/*.................................................................................................................*/    	 public String getMatrixName(Taxa taxa, int ic, CommandRecord commandRec) {    		CharacterData data;    		if (!MesquiteInteger.isCombinable(ic))    			return "";    		if (dataClass == null)  			data = getProject().getCharacterMatrix(taxa, ic);    		else    			data =  getProject().getCharacterMatrix(taxa, ic, dataClass);    		if (data !=null)    			return data.getName();    		return "";   	 }	/*.................................................................................................................*/   	public  MCharactersDistribution getMatrix(Taxa taxa, int im, CommandRecord commandRec){		checkCurrentDataSet(taxa, getProject().getCharacterMatrix(taxa, im, dataClass), commandRec, false);   		commandRec.tick("Getting stored matrix " + im);   		return getM(taxa, commandRec);   	}	/*.................................................................................................................*/   	/** gets the current matrix.*/   	public MCharactersDistribution getCurrentMatrix(Taxa taxa, CommandRecord commandRec){  		if (taxa!=null && !taxa.equals(this.taxa, false)){//taxa==null ||    			if (data!=null)   				data.removeListener(this);   			data = null;   		}		checkCurrentDataSet(taxa, null, commandRec, false);   		return getM(taxa, commandRec);   	}   	/** returns the number of the current matrix*/   	public int getNumberCurrentMatrix(){   		return getProject().getMatrixNumber(data);   	}	/*.................................................................................................................*/    	 public String getName() {		return "Stored Matrices";     	 }   	 	/*.................................................................................................................*/  	 public boolean showCitation() {		return true;   	 }	/*.................................................................................................................*/	/** returns whether this module is requesting to appear as a primary choice */   	public boolean requestPrimaryChoice(){   		return true;     	}	/*.................................................................................................................*/   	  	/** returns an explanation of what the module does.*/ 	public String getExplanation() { 		return "Supplies character matrices from data files (as opposed to simulated characters, for example)." ;   	 }	/*.................................................................................................................*/ 	/** returns current parameters, for logging etc..*/ 	public String getParameters() { 		if (data!=null && getHiredAs() == CharMatrixOneSource.class)			return "Current Matrix: " + data.getName();		else if (getProject() != null)			return "Character Matrices from file: " + getProject().getName();		else			return null;   	 }   	 	/*.................................................................................................................*/ 	/** returns current parameters, for logging etc..*/ 	public String getNameAndParameters() { 		if (data!=null && getHiredAs() == CharMatrixOneSource.class)			return "Stored Matrix: " + data.getName();		else if (getProject() != null)			return "Character Matrices from file: " + getProject().getName();		else			return null;   	 }   	 public void endJob() {   		if (data!=null) data.removeListener(this);   	 	super.endJob();   	 }   	 }class CSMCompatibilityTest extends CompatibilityTest{	public  boolean isCompatible(Object obj, MesquiteProject project, EmployerEmployee prospectiveEmployer){		if (obj == null)			return (project == null || project.getNumberCharMatrices()>0);		if (!(obj instanceof Class) || !(CharacterState.class.isAssignableFrom((Class)obj)))			return true;		if (project==null)			return true;		else			return ( project.getNumberCharMatrices((Class)obj)>0); //still not perfect, since data set might apply to other taxa	}}
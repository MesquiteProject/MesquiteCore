/* Mesquite.chromaseq source code.  Copyright 2005 D. Maddison, W. Maddison. Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.chromaseq.ViewChromatograms; import java.awt.*;import mesquite.chromaseq.lib.*;import mesquite.lib.*;import mesquite.lib.table.TableTool;class ChromatogramPanel extends MesquitePanel {		ChromatogramCanvas chromArea;	Chromatogram chromatogram;	int centerBase = 0;	int centerPixel = 0;	ChromatogramWindow window;	int width = 0;	int height = 0;	boolean colorByQuality = true;	boolean fadeLowQuality = false;	boolean fadeNonSourceRead = false;	int fadeQualityThreshold = 30;	boolean showReadName = true;	boolean showBaseNumberWithinRead = true;	boolean showReadMatrixConflict = true;	boolean showA = true;	boolean showC = true;	boolean showG = true;	boolean showT = true;	boolean scrollToTouched = false;	boolean showBaseSource = true;	boolean showCodonPosition = false;	int id;	int conflictLevelThreshold = 30;	boolean dimLowQualityConflicts = true;	boolean showMagPanel = false;		public ChromatogramPanel(Chromatogram myChrom, ChromatogramWindow window, int id) {		super();		this.id = id;  // this is the read number		this.window = window;		addKeyListener(window);		chromatogram = myChrom;		chromatogram.setWindow(window);		chromArea = new ChromatogramCanvas(this, id);		//this.setLayout(new BorderLayout(0,0));		chromArea.setBounds(0, 0, getWidth(), getHeight());		this.add("Center",chromArea);		if (chromatogram.getRead().getComplemented()) 			setBackground(ColorDistribution.veryVeryLightGray);		else			setBackground(Color.white);	}	public int getWidth() {		if (showMagPanel)			return getBounds().width-100;		else			return getBounds().width;	}		public int getHeight() {		return getBounds().height;	}		boolean listen = true;	//uses index in consensus; this viewer must translate to index in the read	public boolean selectConsensusPositionInChrom(int i, boolean sel, boolean repaint){		if (!listen)			return false;		if (chromArea != null)			return chromArea.setSelectedInChrom(window.getOverallBaseFromConsensusBase(i), sel, repaint);		return false;	}	//this is consensus position	public void exportSelectConsensusPosition(int i){		listen = false;		window.selectConsensusPositionInTable(i);				window.setSelectedConsensusPositionInChrom(i, true, true);			listen = true;	}	//this is consensus position	public void exportDeselectConsensusPosition(int i){		listen = false;		window.deselectConsensusPositionInTable(i);		window.setSelectedConsensusPositionInChrom(i, false, true);		listen = true;	}	public void exportDeselectAll(){		listen = false;		window.deselectAllInTable();		window.deselectAllInPanels();		listen = true;	}	public void deselectAllChrom(int overallBase){		window.deselectAllChrom(overallBase);	}	public void deselectAll(){		chromArea.deselectAll();	}	public void deselectAll(int overallBase){		chromArea.setSelected(overallBase,false);	}	public void synchChromToTable(boolean synchPosition){		window.synchChromToTable(synchPosition);	}	public void synchTableToChrom(boolean synchPosition){		window.synchTableToChrom(synchPosition);	}	public void repaintPanel(){		if (chromArea != null ) {				chromArea.repaint();		}	}	public void setMagnification(double mag){		if (chromArea != null ) {			chromArea.setMagnification(mag);	}			}	public Dimension minimumSize() {		return new Dimension(100,100);	}	/*.................................................................................................................*/	public Read getRead() {		if (chromatogram==null)			return null;		return chromatogram.getRead();	}	/*.................................................................................................................*/	public Contig getContig() {		return window.getContig();	}		/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		this.fadeQualityThreshold = fadeQualityThreshold;	}	/*.................................................................................................................*/	public int getFadeQualityThreshold() {		return fadeQualityThreshold;	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		this.showBaseNumberWithinRead = showBaseNumberWithinRead;	}	/*.................................................................................................................*/	public boolean getShowBaseNumberWithinRead() {		return showBaseNumberWithinRead;	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		this.showReadName = showReadName;	}	/*.................................................................................................................*/	public boolean getShowReadName() {		return showReadName;	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean showReadMatrixConflict) {		this.showReadMatrixConflict = showReadMatrixConflict;	}	/*.................................................................................................................*/	public boolean getShowReadMatrixConflict() {		return showReadMatrixConflict;	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		this.fadeLowQuality = fadeLowQuality;	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		this.fadeNonSourceRead = fadeNonSourceRead;	}	/*.................................................................................................................*/	public boolean getFadeNonSourceRead() {		return fadeNonSourceRead;	}	/*.................................................................................................................*/	public boolean getFadeLowQuality() {		return fadeLowQuality;	}	/*.................................................................................................................*/	public  void setDimConflictMarkerThreshold (int conflictLevelThreshold){		this.conflictLevelThreshold = conflictLevelThreshold;	}	/*.................................................................................................................*/	public  int getDimConflictMarkerThreshold (){		return conflictLevelThreshold;	}	/*.................................................................................................................*/	public  void setDimLowQualityConflicts (boolean dimLowQualityConflicts){		this.dimLowQualityConflicts = dimLowQualityConflicts;	}	/*.................................................................................................................*/	public  boolean getDimLowQualityConflicts (){		return dimLowQualityConflicts;	}/*.................................................................................................................*/	public void setColorByQuality(boolean colorByQuality) {		this.colorByQuality = colorByQuality;	}	/*.................................................................................................................*/	public boolean getColorByQuality() {		return colorByQuality;	}	/*.................................................................................................................*/	public void setShowA(boolean showA) {		this.showA = showA;	}	/*.................................................................................................................*/	public boolean getShowA() {		return showA;	}	/*.................................................................................................................*/	public void setShowC(boolean showC) {		this.showC = showC;	}	/*.................................................................................................................*/	public boolean getShowC() {		return showC;	}	/*.................................................................................................................*/	public void setShowG(boolean showG) {		this.showG = showG;	}	/*.................................................................................................................*/	public boolean getShowG() {		return showG;	}	/*.................................................................................................................*/	public void setShowT(boolean showT) {		this.showT = showT;	}	/*.................................................................................................................*/	public boolean getShowT() {		return showT;	}	/*.................................................................................................................*/	public void setShowCodonPosition(boolean showCodonPosition) {		this.showCodonPosition= showCodonPosition;	}	/*.................................................................................................................*/	public boolean getShowCodonPosition() {		return showCodonPosition;	}	/*.................................................................................................................*/	public void setScrollToTouched(boolean scrollToTouched) {		this.scrollToTouched = scrollToTouched;	}	/*.................................................................................................................*/	public boolean getScrollToTouched() {		return scrollToTouched;	}		public boolean getShowBaseSource() {		return showBaseSource;	}	public void setShowBaseSource(boolean showBaseSource) {		this.showBaseSource = showBaseSource;	}	public void centerPanelAtOverallPosition(int i){		centerBase = i;		chromArea.repaint();	}	public boolean getSelected(int overallBase) {		return chromArea.getSelected(overallBase);	}		public  void setBounds(int x, int y, int width, int height) {		super.setBounds(x,y,width,height);		this.width = width;		this.height = height;		chromArea.setBounds(0, 0, getWidth(), getHeight());		chromArea.repaint();	}	public  void setSize( int width, int height) {		super.setSize(width,height);		this.width = width;		this.height = height;		chromArea.setBounds(0, 0, getWidth(), getHeight());		chromArea.repaint();	}}class ChromatogramCanvas extends MousePanel {	ChromatogramPanel chromatogramPanel;	ChromatogramWindow window;	Chromatogram chromatogram; 	Read read;	int[] A,C,G,T;	int maxValue;	int centerPixel;	int leftPixel;	int centerBase;	private boolean[] selected;  // uses local read as index	int id;	/*..........................*/	public ChromatogramCanvas(ChromatogramPanel parentV, int id) {		super();		this.id = id;		chromatogramPanel = parentV;		window = chromatogramPanel.window;		addKeyListener(window);		chromatogram = parentV.chromatogram;//		setBackground(Color.white);		read = chromatogram.getRead();		if (read.getComplemented()) 			setBackground(ColorDistribution.veryVeryLightGray);		A = chromatogram.getATrace();		C = chromatogram.getCTrace();		G = chromatogram.getGTrace();		T = chromatogram.getTTrace();		int i;		maxValue = 0;		selected = new boolean[window.getTotalNumPeaks()];   // uses local read as index				for (i=0;i<window.getTotalNumPeaks();i++) {			selected[i] = false;		}		for (i=0;i<chromatogram.getTraceLength();i++) {			if (A[i] > maxValue) maxValue = A[i];			if (C[i] > maxValue) maxValue = C[i];			if (G[i] > maxValue) maxValue = G[i];			if (T[i] > maxValue) maxValue = T[i];		}	}	/*...........................................................................*/	/** Given a pixel offset from left, returns the consensus position at that point *	public int OLDfindConsensusPosition(int xPixel){ //this needs to return consensus position!		reCalcCenterBase();		for (int i=0;i < chromatogram.getBaseNumber();i++) {			if (xPixel < chromatogram.getReadBaseLocationAligned(i) - leftPixel - 5)				return getConsensusBaseFromReadBase(i-1);		}		if (xPixel < chromatogram.getReadBaseLocationAligned(chromatogram.getBaseNumber()-1) - leftPixel - 5+30)			return getConsensusBaseFromReadBase(chromatogram.getBaseNumber()-1);		return -1;	}	/*...........................................................................*/	private void reCalcCenterBase(){		centerBase = chromatogramPanel.centerBase;   //number of centered base		centerPixel = window.getCenterPixelFromCenterBase(centerBase);   //number of pixels over this scrolled base is		leftPixel=centerPixel-getBounds().width/2;	}		double magnification = 1.0;	public void setMagnification(double mag){		this.magnification = mag;		repaint();	}	/*...........................................................................*/	public int leftEdgeOfConsensusBase(Graphics g, int i) {			return 0;	}	/*...........................................................................*/	/** Given a pixel offset from left, returns the consensus position at that point. This is not the overall consensus position, zero-based,	 * but instead the position from the start of the main contig. Thus,  positions to the left of the main contig are -ve */	public int findOverallBaseNumber(int xPixel){ //this needs to return consensus position!		int cons = findConsensusBaseNumber(xPixel);		int overall = window.getOverallBaseFromConsensusBase(cons);		return overall;	}	/*...........................................................................*/	/** Given a pixel offset from left, returns the consensus position at that point. This is not the overall consensus position, zero-based,	 * but instead the position from the start of the main contig. Thus,  positions to the left of the main contig are -ve *	public int OLDfindConsensusBaseNumber(int xPixel){ //this needs to return consensus position!		//David: 		/* this isn't finding the consensus base number properly in the first read of lapsiines.nex.  Click to awar from the midline on the		 * read, and it will select too far away from the midline		 *		Graphics g = getGraphics();		Font f = null;		if (g != null)			f = g.getFont();				reCalcCenterBase();		//int firstReadLocation = (chromatogram.getReadBaseLocation(getReadBaseFromConsensusBase(centerBase-window.getContig().getReadExcessAtStart()))-getBounds().width/2);		int firstReadLocation = getFirstReadLocation();		int offsetForInserted = 0;		for (int i=0;i < chromatogram.getBaseNumber();i++) {			int cmid = 10;			int consensusBase = getConsensusBaseFromReadBase(i);			offsetForInserted += window.getSpaceInsertedBeforeConsensusBase(consensusBase);			if (f != null)				cmid = getFontMetrics(f).charWidth(chromatogram.getBase(i)) / 2;			if (xPixel < chromatogram.getReadBaseLocation(i) - firstReadLocation - cmid + offsetForInserted) {				int cons = getConsensusBaseFromReadBase(i-1);//Debugg.println("findConsensusPosition i  " + i  + chromatogram.getBase(i) + "  " + cons);				return cons;			}		}		if (xPixel < chromatogram.getReadBaseLocation(chromatogram.getBaseNumber()-1) - firstReadLocation - leftPixel - 5+30)			return getConsensusBaseFromReadBase(chromatogram.getBaseNumber()-1);		return -window.getOverallBaseFromConsensusBase(0)-1;	}	/*...........................................................................*/	/** Given a pixel offset from left, returns the consensus position at that point. This is not the overall consensus position, zero-based,	 * but instead the position from the start of the main contig. Thus,  positions to the left of the main contig are -ve */	public int findConsensusBaseNumber(int xPixel){ //this needs to return consensus position!		reCalcCenterBase();		int cwidth = getBounds().width;		int halfPeaks = window.getApproximateNumberOfPeaksVisible()/2;		int centerConsensusBase = centerBase-window.getContig().getReadExcessAtStart();		int centerReadBase = getReadBaseFromConsensusBase(centerConsensusBase);		int firstReadBase = centerReadBase - halfPeaks;		int lastReadBase = centerReadBase+halfPeaks;				int firstReadLocation = read.getPhdLocation(centerReadBase,window,true) - cwidth/2;		int count = 0;		while (read.getPhdLocation(firstReadBase,window,true)  - firstReadLocation >0 && firstReadLocation>0 && count++<200)				firstReadBase--; //correcting for error in numpeaksvisible for this read		count = 0;		while (read.getPhdLocation(lastReadBase,window,true)  - firstReadLocation <cwidth && count++<200)				lastReadBase++; //correcting for error in numpeaksvisible for this read		firstReadBase--;		lastReadBase++;		return findConsensusBaseNumber(xPixel, firstReadBase, lastReadBase, firstReadLocation);	}		/*...........................................................................*/	/** Given a pixel offset from left, returns the consensus position at that point. This is not the overall consensus position, zero-based,	 * but instead the position from the start of the main contig. Thus,  positions to the left of the main contig are -ve */	public int findConsensusBaseNumber(int xPixel, int firstReadBase, int lastReadBase, int firstReadLocation){ //this needs to return consensus position!		Graphics g = getGraphics();		Font f = null;		if (g != null)			f = g.getFont();		FontMetrics fm = null;		if (f != null)			fm = getFontMetrics(f);		int offsetForInserted = 0;				for (int i=firstReadBase;i < chromatogram.getBaseNumber() && i<=lastReadBase;i++) {			if (i>=0 && i<read.getBasesLength()) {				int consensusBase = getConsensusBaseFromReadBase(i);				int space = window.getSpaceInsertedBeforeConsensusBase(consensusBase);				offsetForInserted += space;								int overallBase = window.getOverallBaseFromConsensusBase(consensusBase);								int cmid = 10;				if (fm != null)					cmid = fm.charWidth(chromatogram.getBase(i)) / 2;				int w = 0;				if (i+1< chromatogram.getBaseNumber())					//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;					w = read.getPhdLocation(i+1, window,true) - read.getPhdLocation(i, window,true) + 1;				else					w =  (int)window.getAveragePeakDistance();				int h = read.getPhdLocation(i, window,true)- firstReadLocation - cmid - 2 + offsetForInserted;				if (xPixel >= h && xPixel < h + w) {					int cons = getConsensusBaseFromReadBase(i);					return cons;				}				if (xPixel < h + w){					int cons = getConsensusBaseFromReadBase(i);				//	Debugg.println("xPixel " + xPixel + " cons " + cons);					return MesquiteInteger.unassigned;				}			}		}		if (xPixel < chromatogram.getReadBaseLocation(chromatogram.getBaseNumber()-1) - firstReadLocation - leftPixel - 5+30)			return getConsensusBaseFromReadBase(chromatogram.getBaseNumber()-1);		return -window.getOverallBaseFromConsensusBase(0)-1;			}/*...........................................................................*/	public void paint(Graphics g) {				Read read = chromatogram.getRead();		int cheight = getBounds().height;		int shadowHeight = 5;		int labelHeight = 18;		int labelBottom = cheight-shadowHeight;		int labelTop = labelBottom-labelHeight+1;		int peakBottom = labelBottom - labelHeight;		int cwidth = getBounds().width;		double scale = 1.0*maxValue / cheight / magnification;		int halfPeaks = window.getApproximateNumberOfPeaksVisible()/2;		reCalcCenterBase();		int centerConsensusBase = centerBase-window.getContig().getReadExcessAtStart();		int centerReadBase = getReadBaseFromConsensusBase(centerConsensusBase);		int firstReadBase = centerReadBase - halfPeaks;		int lastReadBase = centerReadBase+halfPeaks;				int firstReadLocation = read.getPhdLocation(centerReadBase,window,true) - cwidth/2;				/*David: here a correction is introduced to discover what is actually the first and last read bases visible.  Previously		these bases were calcualted incorrectly if some reads were effectively compressed, and thus drawing didn't go all the way to the edges				A similar problem of compression was affecting findConsensusBaseNumber, hence some of this code is repeated there.				*/		 int count = 0;		while (read.getPhdLocation(firstReadBase,window,true)  - firstReadLocation >0 && firstReadLocation>0 && count++<200)				firstReadBase--; //correcting for error in numpeaksvisible for this read		count = 0;		while (read.getPhdLocation(lastReadBase,window,true)  - firstReadLocation <cwidth && count++<200)				lastReadBase++; //correcting for error in numpeaksvisible for this read		firstReadBase--;		lastReadBase++;		double nonSourceDimFraction = 0.2;		int i;		double fadeMax = 0.5;		int offsetForInserted = 0;//		Now to show the read-matrix conflict marker		if (MesquiteWindow.Java2Davailable){			int firstSel = MesquiteInteger.unassigned;			ColorDistribution.setTransparentGraphics(g);					int cmid = 0;			for (i=firstReadBase-1; i<=lastReadBase+1;i++) {				if (i>=0 && i<read.getBasesLength()) {					int consensusBase = getConsensusBaseFromReadBase(i);					offsetForInserted += window.getSpaceInsertedBeforeConsensusBase(consensusBase);					int overallBase = window.getOverallBaseFromConsensusBase(consensusBase);										char c = read.getPhdBaseChar(i);					if (chromatogramPanel.getShowReadMatrixConflict()){						consensusBase = getConsensusBaseFromReadBase(i);						char contigBase = window.getMatrixStateAtConsensusPosition(consensusBase);						if (contigBase != c) {							int quality = read.getPhdBaseQuality(i);							if (chromatogramPanel.getDimLowQualityConflicts()) {								if (quality==0)									continue;								else if (quality>=chromatogramPanel.getDimConflictMarkerThreshold())									g.setColor(ColorDistribution.burlyWood);								else									g.setColor(ColorDistribution.brighter(ColorDistribution.burlyWood, (float)(quality/(1.0*chromatogramPanel.getDimConflictMarkerThreshold()))));							}							else 								g.setColor(ColorDistribution.burlyWood);							int rightLoc = read.getPhdRightBoundary(i,window,true);							int leftLoc = read.getPhdLeftBoundary(i,window,true);							g.fillRect(leftLoc - firstReadLocation + offsetForInserted, 0, rightLoc-leftLoc, labelTop-1);							g.setColor(Color.gray);						}					}				}			}			ColorDistribution.setOpaqueGraphics(g);				}						offsetForInserted = 0;//		 Color the codon position		if (chromatogramPanel.getShowCodonPosition()) {			if (MesquiteWindow.Java2Davailable){				ColorDistribution.setTransparentGraphics(g,0.2f);						for (i=firstReadBase; i<=lastReadBase;i++) {					if (i>=0 && i<read.getBasesLength()) {						int consensusBase = getConsensusBaseFromReadBase(i);						offsetForInserted += window.getSpaceInsertedBeforeConsensusBase(consensusBase);						int overallBase = window.getOverallBaseFromConsensusBase(consensusBase);						int codonPosition = window.getCodonPositionOfOverallBase(overallBase);						if (codonPosition>0 && codonPosition<4) {							switch (codonPosition) {							case 1: g.setColor(Color.blue); break;							case 2: g.setColor(Color.green); break;							case 3: g.setColor(Color.red); break;							default: g.setColor(Color.white); break;							}							int w = read.getPhdRightBoundary(i,window,true) - read.getPhdLeftBoundary(i,window,true);							int hor = read.getPhdLeftBoundary(i, window,true)- firstReadLocation + offsetForInserted;							g.fillRect(hor, 16, w, 26);						}					}				}				ColorDistribution.setOpaqueGraphics(g);					}		}		offsetForInserted =0;//Drawing the center line		g.setColor(Color.lightGray);		g.drawLine(cwidth/2,0,cwidth/2,cheight);										//Drawing the peaks				int prevCons = 0;		int lostSpaceByInsert = 0;		int lastReadPos = MesquiteInteger.unassigned;		for (i=0;i < cwidth-2;i+=2) {   //this goes through the pixels that are to be displayed, and sees if any from this read are in here			int readPos = i+firstReadLocation;  //this is pixels in the whole thing						int ic = findConsensusBaseNumber(i, firstReadBase, lastReadBase, firstReadLocation);			if (MesquiteInteger.isCombinable(ic)){				if (MesquiteInteger.isCombinable(lastReadPos))					lostSpaceByInsert += readPos - lastReadPos -2;				lastReadPos = readPos;				readPos -= lostSpaceByInsert;				if (readPos>=0&&readPos+2<A.length) {  //is it within bounds of read?					if (prevCons != ic) {					//	offsetForInserted += spaceFollows;						offsetForInserted += window.getSpaceInsertedAfterConsensusBase(ic);						//offsetForInserted += space;					}													   		int readBaseNumber = read.getReadBaseFromConsensusBase(ic);										prevCons=ic;										int qual = read.getPhdBaseQuality(readBaseNumber);					if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())						if (qual==0)							continue;						else 							ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));					if (chromatogramPanel.getFadeNonSourceRead()) {						int consensusBase = getConsensusBaseFromReadBase(readBaseNumber);						int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);						if (readUsed!=id) {							ColorDistribution.setTransparentGraphics(g,(float)nonSourceDimFraction);						}					}					int pixels = window.getHorizontalPixels(i);//+ offsetForInserted);  //returns scaled horizontal pixels				/*temporary; to illustrate what read base the curve thinks its on *					//char c = read.getPhdBaseChar(readBaseNumber);					char c = window.getMatrixStateAtConsensusPosition(ic);					Color tempC = window.getBaseColor(c);					g.setColor(tempC);					g.fillRect(pixels, 0, 2, 1000);	/**/										if (chromatogramPanel.getShowA()) {						g.setColor(Color.green);						g.drawLine(pixels,peakBottom-(int)(A[readPos] / scale),pixels+2,peakBottom-(int)(A[readPos+2] / scale));					}					if (chromatogramPanel.getShowC()) {						g.setColor(Color.blue);						g.drawLine(pixels,peakBottom-(int)(C[readPos] / scale),pixels+2,peakBottom-(int)(C[readPos+2] / scale));					}					if (chromatogramPanel.getShowG()) {						g.setColor(Color.black);						g.drawLine(pixels,peakBottom-(int)(G[readPos] / scale),pixels+2,peakBottom-(int)(G[readPos+2] / scale));					}					if (chromatogramPanel.getShowT()) {						g.setColor(Color.red);						g.drawLine(pixels,peakBottom-(int)(T[readPos] / scale),pixels+2,peakBottom-(int)(T[readPos+2] / scale));					}					if (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead())						ColorDistribution.setOpaqueGraphics(g);				}			}		}//Drawing the read name				if (!StringUtil.blank(chromatogram.getTitle()) && chromatogramPanel.getShowReadName()) {			if (chromatogram.getRead().getComplemented())				g.setColor(Color.red);			else				g.setColor(Color.black);			g.drawString(chromatogram.getTitle(),10,30); 		}		offsetForInserted = 0;// Now to color the base letters under the peaks		for (i=firstReadBase;i < chromatogram.getBaseNumber() && i<=lastReadBase;i++) {			if (i>=0 && i<read.getBasesLength()) {				int consensusBase = getConsensusBaseFromReadBase(i);				int space = window.getSpaceInsertedBeforeConsensusBase(consensusBase);				offsetForInserted += space;								int overallBase = window.getOverallBaseFromConsensusBase(consensusBase);				char c = read.getPhdBaseChar(i);				int qual = read.getPhdBaseQuality(i);				if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())					if (qual==0)						continue;					else 						ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));				if (chromatogramPanel.getFadeNonSourceRead()) {					int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);					if (readUsed!=id) {						ColorDistribution.setTransparentGraphics(g,(float)nonSourceDimFraction);					}				}								int cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;				int w = 0;				if (i+1< chromatogram.getBaseNumber())					//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;					w = read.getPhdLocation(i+1, window,true) - read.getPhdLocation(i, window,true) + 1;				else					w =  (int)window.getAveragePeakDistance();				if (qual>=0 && window.getColorByQuality()) {					if (qual==0)						g.setColor(ColorDistribution.brighter(AceFile.getColorOfQuality(qual),0.2));					else						g.setColor(ColorDistribution.brighter(AceFile.getColorOfQuality(qual),0.5));	/*	char cc= window.getMatrixStateAtConsensusPosition(consensusBase);		Color tempC = window.getBaseColor(cc);		g.setColor(tempC);*/					g.fillRect(read.getPhdLocation(i, window,true)- firstReadLocation - cmid - 2 + offsetForInserted, labelTop, w, labelHeight);				}								if (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead())					ColorDistribution.setOpaqueGraphics(g);				if (!MesquiteWindow.Java2Davailable){					if (selected[overallBase]){						w = 0;						if (i+1< chromatogram.getBaseNumber())							//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;							w = read.getPhdLocation(i+1, window,true) - read.getPhdLocation(i, window,true) + 1;						else							w =  (int)window.getAveragePeakDistance();						g.setColor(Color.gray);						g.fillRect(read.getPhdLocation(i, window,true)- firstReadLocation - cmid - 2 + offsetForInserted, labelTop, w, labelHeight);					}				}			}		}				offsetForInserted = 0;// Now to show the selection		if (MesquiteWindow.Java2Davailable){			int firstSel = MesquiteInteger.unassigned;			ColorDistribution.setTransparentGraphics(g);					g.setColor(Color.gray);			int cmid = 0;			for (i=firstReadBase-1; i<=lastReadBase+1;i++) {				if (i>=0 && i<read.getBasesLength()) {					int consensusBase = getConsensusBaseFromReadBase(i);				    offsetForInserted += window.getSpaceInsertedBeforeConsensusBase(consensusBase);					int overallBase = window.getOverallBaseFromConsensusBase(consensusBase);					char c = read.getPhdBaseChar(i);					cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;					if (selected[overallBase]){						if (firstSel == MesquiteInteger.unassigned)							firstSel = read.getPhdLocation(i, window,true)- firstReadLocation - cmid - 2 + offsetForInserted;					}					else if (firstSel != MesquiteInteger.unassigned){						int endOfSel = read.getPhdLocation(i, window,true)- firstReadLocation - cmid - 2 + offsetForInserted;						g.fillRect(firstSel, 0, endOfSel - firstSel, cheight);						firstSel = MesquiteInteger.unassigned;					}				}			}			if (firstSel != MesquiteInteger.unassigned){ //unfinished selection						int endOfSel = read.getPhdLocation(lastReadBase+1, window,true)- firstReadLocation - 2 + offsetForInserted;						g.fillRect(firstSel, 0, endOfSel - firstSel, cheight);						firstSel = MesquiteInteger.unassigned;					}			ColorDistribution.setOpaqueGraphics(g);				}		offsetForInserted = 0;// Now to write the bases below the peaks		for (i=firstReadBase;i < chromatogram.getBaseNumber() && i<=lastReadBase;i++) {			if (i>=0 && i<read.getBasesLength()) {				int consensusBase = getConsensusBaseFromReadBase(i);				offsetForInserted += window.getSpaceInsertedBeforeConsensusBase(consensusBase);				int overallBase = window.getOverallBaseFromConsensusBase(consensusBase);				char c = read.getPhdBaseChar(i);				int qual = read.getPhdBaseQuality(i);				if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())					ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));				if (chromatogramPanel.getFadeNonSourceRead()) {					int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);					if (readUsed!=id) {						ColorDistribution.setTransparentGraphics(g,(float)nonSourceDimFraction);					}				}								int cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;				Color textC = window.getBaseColor(c);				int pixels = window.getHorizontalPixels(read.getPhdLocation(i, window,true) - firstReadLocation) + offsetForInserted;				if (!MesquiteWindow.Java2Davailable && selected[overallBase]){					StringUtil.highlightString(g, String.valueOf(c), pixels - cmid, labelBottom-3, textC, Color.white);				}				else {					g.setColor(textC);					GraphicsUtil.setFontStyle(Font.BOLD,g);					GraphicsUtil.setFontSize(12,g);					g.drawString(""+c,pixels - cmid, labelBottom-3);					GraphicsUtil.setFontStyle(Font.PLAIN,g);				}								if ((i+1) % 10 == 0 && chromatogramPanel.getShowBaseNumberWithinRead()) {					g.setColor(Color.gray);					GraphicsUtil.setFontSize(10,g);					int nmid = getFontMetrics(g.getFont()).stringWidth(String.valueOf(i+1)) / 2;					g.drawString(String.valueOf(i+1),pixels - nmid,12);				}				if (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead())					ColorDistribution.setOpaqueGraphics(g);								if (chromatogramPanel.getShowBaseSource()) {					consensusBase = getConsensusBaseFromReadBase(i);					int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);					if (readUsed==id) {						g.setColor(ColorDistribution.sienna);						int rightLoc = read.getPhdRightBoundary(i,window,true);						int leftLoc = read.getPhdLeftBoundary(i,window,true);						g.fillRect(leftLoc - firstReadLocation + offsetForInserted, labelTop, rightLoc-leftLoc, 3);					}				}							}		}		//		Drawing the bottom line		g.setColor(Color.black);		g.drawLine(0,cheight-5,cwidth,cheight-5);		g.drawLine(0,cheight-4,cwidth,cheight-4);		g.setColor(Color.gray);		g.drawLine(0,cheight-3,cwidth,cheight-3);		g.setColor(Color.lightGray);		g.drawLine(0,cheight-2,cwidth,cheight-2);		g.setColor(ColorDistribution.veryLightGray);		g.drawLine(0,cheight-1,cwidth,cheight-1);//Debugg.println("end of paint, "+chromatogram.getTitle());	}		/*...........................................................................*/	public int getFirstReadLocation() {			int cwidth = getBounds().width;		reCalcCenterBase();		int centerConsensusBase = centerBase-window.getContig().getReadExcessAtStart();		int centerReadBase = getReadBaseFromConsensusBase(centerConsensusBase);//		int firstReadLocation = read.getPhdLocation(centerReadBase,window,true) - cwidth/2;		int firstReadLocation = chromatogram.getReadBaseLocation(centerReadBase) - cwidth/2;		return firstReadLocation;		//int firstReadLocation = (chromatogram.getReadBaseLocation(getReadBaseFromConsensusBase(centerBase-window.getContig().getReadExcessAtStart()))-getBounds().width/2);			}  	 /*--------------------------------------*/	/*This returns for read position i, what is the position in the consensus. */	public int getConsensusBaseFromReadBase(int i){		Read read = chromatogram.getRead();		if (read!=null)			return read.getConsensusBaseFromReadBase(i);		else 			return i;			}	public void deselectAll(){		for (int i = 0; i<selected.length; i++)			selected[i]=false;	} 	 /*--------------------------------------*/	public void setSelected(int overallBase, boolean sel){		if (overallBase>=0||overallBase<selected.length)			selected[overallBase]= sel;	} 	 /*--------------------------------------*/	public boolean getSelected(int overallBase){		if (overallBase<0||overallBase>=selected.length)			return false;		return selected[overallBase];	}  	 /*--------------------------------------*/	/*This returns for consensus position i, what is the position in the read. */	public int getReadBaseFromConsensusBase(int i){		Read read = chromatogram.getRead();		if (read!=null)			return read.getReadBaseFromConsensusBase(i);  		else			return i;	}   	 /*--------------------------------------*/	/** Given the overall base number overallBase, this method selects that base within this chromatogram.	 * Note that it does NOT translate to the base number within the read, as selection can now happen even if 	 * there is no read there */	public boolean setSelectedInChrom(int overallBase, boolean sel, boolean repaint){// why is this called an absurd number of times  Debugg.println("1");		if (selected != null && overallBase >= 0 && overallBase<selected.length) {			if (selected[overallBase] == sel)					return false;			selected[overallBase] = sel;  //selected uses index in consensus			if (repaint)				repaint();			return true;		}		return false;// Debugg.println("2");	}   	 /*--------------------------------------*/	/** Given the overall base numbering, as given in overallBase, this method selects that base within this contig*/	public void selectOverallBase(int overallBase){		int consensusBase = window.getConsensusBaseFromOverallBase(overallBase);//		int readBase = getReadBaseFromConsensusBase(consensusBase);//		if (j <0 || j>= chromatogram.getTraceLength())//			return;		if (overallBase <0 || overallBase> selected.length)			return;		selected[overallBase] = true;//Debugg.println("selectOverallBase " + overallBase + " consensusBase " + consensusBase + " readbase " + readBase);		chromatogramPanel.exportSelectConsensusPosition(consensusBase);	}		//this is consensus position	public void deselectOverallBase(int overallBase){		int consensusBase = window.getConsensusBaseFromOverallBase(overallBase);		int readBase = getReadBaseFromConsensusBase(consensusBase);		selected[overallBase] = false;		chromatogramPanel.exportDeselectConsensusPosition(consensusBase);	}	   	 /*--------------------------------------*/	/* to be used by subclasses to tell that panel touched */	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		int ic = findOverallBaseNumber(x); 		boolean onRequiredSelection = chromTool.getWorksOnlyOnSelection() && !getSelected(ic);		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels() &&!onRequiredSelection){			int cons = findConsensusBaseNumber(x);			((ChromatogramTool)tool).touched(cons, cons, true, id, modifiers);
/*		MesquiteWindow w = chromatogramPanel.getMesquiteWindow();		if (w!=null)			w.showQuickMessage(chromatogramPanel,null,x,y,"testing");*/
			return;		}		if (MesquiteEvent.shiftKeyDown(modifiers)){			if (MesquiteInteger.isCombinable(ic)){				window.setSecondTouchedOverall(ic);				chromatogramPanel.exportDeselectAll();				if (MesquiteInteger.isCombinable(window.getFirstTouchedOverall())) {					if (window.getFirstTouchedOverall()>ic){						for (int i = ic; i<=window.getFirstTouchedOverall(); i++)							selectOverallBase(i);					}	   				else {		   				for (int i = window.getFirstTouchedOverall(); i<=ic; i++)		   					selectOverallBase(i);	   				}	  			}	  			else {		  			selectOverallBase(ic);	  			}				//chromatogramPanel.synchTableToChrom(false);				window.repaintPanels();	  		} 		}  		else if (MesquiteEvent.commandOrControlKeyDown(modifiers)){	   		if (MesquiteInteger.isCombinable(ic)){	  			selectOverallBase(ic);	  			window.repaintPanels();	  		} 		} 		else {	   		if (MesquiteInteger.isCombinable(ic)){	   			window.setFirstTouchedOverall(ic);	   			chromatogramPanel.exportDeselectAll();	  			selectOverallBase(ic);				if (clickCount>1)					window.scrollToOverallBase(ic);	  			window.repaintPanels();	  		} 		}	}	public void mouseDrag (int modifiers, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		int ic = findOverallBaseNumber(x); 		boolean onRequiredSelection = chromTool.getWorksOnlyOnSelection() && !getSelected(ic);		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels() && !onRequiredSelection){			int cons = findConsensusBaseNumber(x);			((ChromatogramTool)tool).dragged(cons, cons, true, id, modifiers);			return;	}   		if (MesquiteInteger.isCombinable(ic)){   			//deselectAll(); //this isn't correct behaviour!  If shift down should remember previously sleected pieces   			if (MesquiteInteger.isCombinable(window.getFirstTouchedOverall())) {				if (window.getFirstTouchedOverall()>ic){	   				if (MesquiteInteger.isCombinable(window.getSecondTouchedOverall()) && window.getSecondTouchedOverall()<window.getFirstTouchedOverall() && ic>window.getSecondTouchedOverall()){ //retracting	   					for (int i = window.getSecondTouchedOverall()+1; i<=ic; i++) 	   						deselectOverallBase(i);		   			}	   				else for (int i = ic; i<=window.getFirstTouchedOverall(); i++) //adding	   					selectOverallBase(i);   				}   				else {		    			if (MesquiteInteger.isCombinable(window.getSecondTouchedOverall()) && window.getSecondTouchedOverall()>window.getFirstTouchedOverall() && ic<window.getSecondTouchedOverall()){ //retracting	   					for (int i = ic+1; i<=window.getSecondTouchedOverall(); i++) 	   						deselectOverallBase(i);		   			}	   				else for (int i = window.getFirstTouchedOverall(); i<=ic; i++)	   					selectOverallBase(i);   				}  			}  			else {	  			selectOverallBase(ic);  			}			//chromatogramPanel.synchTableToChrom(false);   			window.repaintPanels();   			window.setSecondTouchedOverall(ic); 		}	}	/* to be used by subclasses to tell that panel touched */   	public void mouseUp(int modifiers, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels()){				int cons = findConsensusBaseNumber(x);				((ChromatogramTool)tool).dropped(cons, cons, true, id, modifiers);				return;		}  		if (MesquiteInteger.isCombinable(window.getFirstTouchedOverall())){   			if (!MesquiteInteger.isCombinable(window.getSecondTouchedOverall()))   				window.focusMatrixOn(window.getConsensusBaseFromOverallBase(window.getFirstTouchedOverall()), MesquiteInteger.unassigned);   			else   				window.focusMatrixOn(window.getConsensusBaseFromOverallBase(window.getFirstTouchedOverall()), window.getConsensusBaseFromOverallBase(window.getSecondTouchedOverall()));   		}		if (chromatogramPanel.getScrollToTouched()) {			int ic = findConsensusBaseNumber(x);			if (ic>=0)				window.scrollToConsensusBase(ic);		}		window.setSecondTouchedOverall(MesquiteInteger.unassigned);	}	/*.................................................................................................................*/	public String getPeakHeightsOfBase(int readBaseNumber) {   // i is the position, zero-based, in the padded consensus sequence; returns location		if (readBaseNumber<0)			return "";		else {			int[] traceArray = new int[5];			int location = read.getPhdLocation(readBaseNumber,window,true);			String[] baseArray = new String[5];			traceArray[0] = chromatogram.getATrace(location);			baseArray[0]="A";			traceArray[1] = chromatogram.getCTrace(location);			baseArray[1]="C";			traceArray[2] = chromatogram.getGTrace(location);			baseArray[2]="G";			traceArray[3] = chromatogram.getTTrace(location);			baseArray[3]="T";			for (int i = 0; i<4; i++){				int max = IntegerArray.indexOfMaximum(traceArray);				traceArray[4] = traceArray[i];  //store this here temporarily				baseArray[4] = baseArray[i];  //store this here temporarily				traceArray[i] =  traceArray[max];				baseArray[i] = baseArray[max];				traceArray[max] = traceArray[4];				baseArray[max] = baseArray[4];				traceArray[i] = - traceArray[i];				traceArray[4]=0;			}			for (int i = 0; i<4; i++){				if (traceArray[i]<0)					traceArray[i] = -traceArray[i];			}						StringBuffer sb = new StringBuffer();						for (int i = 0; i<4; i++){				if (traceArray[i]>0) {					sb.append(baseArray[i] + ": " + traceArray[i]);					if (i<3 && traceArray[i+1]>0)						sb.append(", ");				}			}						return sb.toString();		}	}	/*...............................................................................................................*/	public void setCurrentCursor(int modifiers, int x, int y, ChromatogramTool tool) {		if (tool == null)			setCursor(getDisabledCursor());		else 	if (tool.getWorksOnChromatogramPanels()) 			setCursor(tool.getCursor());		else			setCursor(getDisabledCursor());	}	/*_________________________________________________*/   	public void mouseMoved(int modifiers, int x, int y, MesquiteTool tool) {   		int ic = findConsensusBaseNumber(x);   		int readBaseNumber = read.getReadBaseFromConsensusBase(ic);   		int quality = read.getPhdBaseQuality(readBaseNumber);   		double averageQuality = read.getAverageQuality();   		int numBasesHighQuality = read.getNumBasesHighQuality();   		String s = "";   		if (quality>=0)   			s+= "Base quality: " + quality + ",   Peak heights: " + getPeakHeightsOfBase(readBaseNumber);  		s+= "\n# Bases with Quality ³ " + read.getNumBasesHighQualityThreshold() + ": " + numBasesHighQuality + ",  Average Quality: " + averageQuality + "  ("+chromatogram.getTitle()+")";  		window.setExplanation( s);   		if (tool == null)			return;   		ChromatogramTool chromTool = (ChromatogramTool)tool;   		if (chromTool.getWorksOnlyOnSelection())   			if (!getSelected(findOverallBaseNumber(x)))   				setCursor(Cursor.getDefaultCursor());   			else   				setCurrentCursor(modifiers, x, y, chromTool); 	}   	   	/*...............................................................................................................*/   	public void mouseExited(int modifiers, int x, int y, MesquiteTool tool) {		setCursor(Cursor.getDefaultCursor());	}	/*...............................................................................................................*/	public void mouseEntered(int modifiers, int x, int y, MesquiteTool tool) {		if (tool == null)			return;		setCurrentCursor(modifiers, x, y, (ChromatogramTool)tool);	}}